/**
 * グローバル単一データストア
 * DRY原則: 同一データは1箇所でのみ管理
 * リアクティビティ粒度を適切に制御するため、変更時の挙動単位でrefを分離
 */

// Vue 3のrefをインポート
const { ref } = Vue;


// === 選択系（個別ref - 依存関係が異なるため分離）===
const 職業 = ref('');
const スキル名 = ref('');
const ダンジョン = ref('');
const 敵名 = ref('');
const 難易度 = ref('');
const スキルレベル = ref(1);  // inputsから独立
const 最大スキルレベル = ref(20);  // スキルの最大レベル

// === UI状態（個別ref）===
const activeMainTab = ref('damage');
const guildSkillGradeFilters = ref({
  初級: true,
  中級: true,
  上級: true
});
const 選択可能スキル = ref([]);
const 選択可能敵 = ref([]);
const 選択可能難易度 = ref([]);

// === マスターデータ（個別ref）===
const スキルマスター = ref([]);
const 敵マスター = ref({});
const 超越スキルマスター = ref([]);
const ギルドスキルマスター = ref([]);
const ペットパッシブマスター = ref([]);
const 職業リスト = ref([]);
const ダンジョンリスト = ref([]);

// === 計算用入力データ（まとめてref - どれか1個変更で再計算）===
const inputs = ref({
  // 基本設定
  攻撃タイプ: '物理',
  スキルタイプ: '攻撃',
  
  // スキル関連
  スキル倍率: 100,
  スキル追加ダメ: 0,
  モーション時間: null,
  ヒット数: null,
  
  // ステータス（Object.keys()で取得可能）
  stats: {
    // 基本ステータス
    筋力: 546424,
    筋力_乗算: 316,
    魔力: 546424,
    魔力_乗算: 316,
    効率: 0,
    体力: 400512,
    体力_乗算: 620,
    幸運: 400948,
    幸運_乗算: 300,
    
    // HP関連
    HP: 4474100,
    HP_乗算: 217,
      
    // 攻撃力
    攻撃最大: 50000,
    攻撃最小: 50000,
    攻撃_乗算: 100,
    属性: 14382,
    属性_乗算: 276,
    
    // ダメージ関連
    物理_クリ率: 50,
    魔法_クリ率: 50,
    物理_クリダメ: 1993,
    魔法_クリダメ: 1993,
    クリダメ_乗算: 0,

    物理_最大: 0,
    魔法_最大: 0,
    最大_乗算: 1310,

    物理_最小: 0,
    魔法_最小: 0,
    最小_乗算: 1473,
  
    // 基礎値
    基礎最大: 105,
    基礎最小: 95,
    
    // 属性最大最小（魔法のみ）
    属性最大: 0,
    属性最小: 0,

    物理_貫通: 90,
    魔法_貫通: 90,

    物理_追加ダメ: 247784,
    魔法_追加ダメ: 247784,
    追加ダメ_乗算: 110,
    
    // 敵タイプ別追加ダメージ・支配
    一般追加ダメ: 122046,
    一般支配: 17.4,
    ボス追加ダメ: 122046,
    ボス支配: 17.4,
  },
    
  // 召喚系
  攻撃補正: 100,
  属性補正: 100,
  ダメ補正: 100,
  
  // 敵関連
  敵タイプ: 'ボス',
  敵防御: 1,
  敵ダメ減: 0,
  敵ダメ減_乗算: 0,
  敵幸運: 1068254,
  敵クリ減: 0,
  
  // HP価値（incr計算用）
  HPダメージ換算: 100,  // HP damage conversion
  
  // 経験値（incr計算用）
  経験値: 1243
});

// 現在選択されているスキルデータを取得
const getCurrentSkillData = () => {
  if (!スキル名.value) return null;
  
  return スキルマスター.value.find(skill => 
    skill.職業 === 職業.value && skill.スキル名 === スキル名.value
  ) || null;
};

// localStorage から入力データを読み込み
const loadFromStorage = () => {
  try {
    const saved = localStorage.getItem('lataleCalcData');
    if (saved) {
      const data = JSON.parse(saved);
      
      // inputs に直接代入
      inputs.value = data.inputs;
      
      // 選択系の更新
      職業.value = data.職業 || '';
      スキル名.value = data.スキル名 || '';
      ダンジョン.value = data.ダンジョン || '';
      敵名.value = data.敵名 || '';
      難易度.value = data.難易度 || '';
      スキルレベル.value = data.スキルレベル || 1;
      return true;
    }
  } catch (error) {
    localStorage.removeItem('lataleCalcData');
  }
  return false;
};

// 入力データを localStorage に保存
const saveToStorage = () => {
  try {
    const data = {
      inputs: inputs.value,
      職業: 職業.value,
      スキル名: スキル名.value,
      ダンジョン: ダンジョン.value,
      敵名: 敵名.value,
      難易度: 難易度.value,
      スキルレベル: スキルレベル.value
    };
    
    localStorage.setItem('lataleCalcData', JSON.stringify(data));
    return true;
  } catch (error) {
    console.error('[saveToStorage] Failed to save settings:', error);
  }
  return false;
};
 
/**
 * ダメージ計算エンジン
 * DRY原則: 計算は1回のみ、動的にキーの存在をチェック
 * 初期化により型を保証、nullチェック不要
 * 
 * 命名規約:
 * - 表示値: ステータス画面に表示される値（補正前値 × 乗算値）
 * - 補正前値: 乗算補正を適用する前のベース値
 * - 乗算値: ％補正の値（100 = 100%増加）
 */

const getStatWithPrefix = (key, stats) => stats[getActualKey(key)];

const isPhysical = () => inputs.value.攻撃タイプ === '物理';

const mulKey = (stat) => {
  if(stat.startsWith('攻撃')) return '攻撃_乗算'
  return stat.replace(/^(物理|魔法)_/, '') + '_乗算';
};

// ベースダメージ計算（1回のみ実行）
function calculateBaseDamage(stats) {
  
  // 初期値設定（型保証）
  let 攻撃力補正 = 1;
  let 属性攻撃補正 = 1;
  let 全ダメージ補正 = 1;
  let 効率 = 1;
  
  const 防御倍率 = 1 / Math.exp(inputs.value.敵防御 / 3761.35);
  const 貫通率 = getStatWithPrefix('貫通', stats) / 100;
  
  // 召喚スキルの特殊処理
  if (inputs.value.スキルタイプ === '召喚') {
    攻撃力補正 = 1;
    属性攻撃補正 = 1;
    全ダメージ補正 = inputs.value.ダメ補正 / 100;
  } else {
    効率 += stats.効率/ 100;
  }
    
  // 物理/魔法で異なるステータス取得
  let 筋魔, 攻撃or属性, 最大, 最小, 追加ダメ;
  
  if (isPhysical()) {
    筋魔 = stats.筋力;
    攻撃or属性 = ((stats.攻撃最大) + (stats.攻撃最小)) * 攻撃力補正;
    最大 = getStatWithPrefix('最大', stats);
    最小 = getStatWithPrefix('最小', stats);
    追加ダメ = getStatWithPrefix('追加ダメ', stats);
  } else {
    筋魔 = stats.魔力;
    攻撃or属性 = (stats.属性) * 2 * 属性攻撃補正;
    最大 = getStatWithPrefix('最大', stats) + (stats.属性最大);
    最小 = getStatWithPrefix('最小', stats) + (stats.属性最小);
    追加ダメ = getStatWithPrefix('追加ダメ', stats);
  }
  
  // 基礎最大最小追加
  最大 = Number(最大) + Number(stats.基礎最大);
  最小 = Number(最小) + Number(stats.基礎最小);
  
  // 敵タイプ別ボーナス
  追加ダメ += stats[inputs.value.敵タイプ + '追加ダメ']
  // 追加ダメージから敵ダメ減（固定値）を差し引く
  追加ダメ -= inputs.value.敵ダメ減;
  const 支配 = stats[inputs.value.敵タイプ + '支配']

  // ダメージ計算
  const 基本ダメージ1 = 攻撃or属性 * inputs.value.スキル倍率 / 100;
  const 基本ダメージ2 = inputs.value.スキル追加ダメ + 筋魔 * 効率;
  最小 = Math.min(最大 + 10, 最小);
    
  const result = (
    (基本ダメージ1 + 基本ダメージ2) * (1 - (1 - 防御倍率) * (1 - 貫通率))
      + 追加ダメ
  )
    * (1 + 支配 / 100)
    * (最大 + 最小) / 200 * 全ダメージ補正
    * (1 - inputs.value.敵ダメ減_乗算 / 100);
  
  return result;
}

// クリティカル率計算
function calculateCriRate(stats) {
  const クリ率 = getStatWithPrefix('クリ率', stats);
  const 幸運 = stats.幸運;
  return Math.min(100, クリ率 + 15 * 幸運 / inputs.value.敵幸運);
}

// クリティカルダメージ計算
function calculateCriDamage(baseDamage, stats) {
  const クリダメ = getStatWithPrefix('クリダメ', stats);
  const クリダメ補正 = (100 + クリダメ) * (1 - inputs.value.敵クリ減 / 1000) / 100;
  return baseDamage * クリダメ補正;
}

// 平均ダメージ計算
function calculateDamage(baseDamage, criRate, criDamage) {
  const cr = criRate / 100;
  const nonCriPart = baseDamage * (1 - cr);
  const criPart = criDamage * cr;
  return nonCriPart + criPart;
}

// DPS計算（モーション時間・ヒット数がnullの場合はnullを返す）
function calculateDPS(damage) {
  
  const motionTimeInSeconds = inputs.value.モーション時間 / 10;
  const hitCount = inputs.value.ヒット数;
  const totalDamage = damage * hitCount;
  
  return totalDamage / motionTimeInSeconds;
}


const calculateDamages = (stats) => {
  const baseDamage = calculateBaseDamage(stats);
  const criRate = calculateCriRate(stats);
  const criDamage = calculateCriDamage(baseDamage, stats);
  const damage = calculateDamage(baseDamage, criRate, criDamage);
  
  return {
    baseDamage,
    criRate,
    criDamage,
    damage
  };
}

// 全計算結果を一度に取得
function calculateResults() {
  const stats = inputs.value.stats;
  const baseResults = calculateDamages(stats);
  const currentDamage = baseResults.damage;

  // DPS計算
  if (inputs.value.モーション時間 === null || inputs.value.ヒット数 === null) {
    baseResults.dps = currentDamage;
  } else {
    baseResults.dps = calculateDPS(currentDamage);
  }

  // ステータス1ポイントあたりのダメージ増加値取得
  const damagePerStatPoint = key => {
    // 特殊ケース: 経験値
    if (key === '経験値') {
      return Math.floor(currentDamage / 100 / (1 + stats[key] / 100));
    }

    // HP関連価値計算
    const hpValue = inputs.value.HPダメージ換算 / 100;
    if (key === 'HP') {
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = (1 + HP_乗算 / 100) / HP;
      return Math.floor(currentDamage * HPincr * hpValue);
    }
    if (key === 'HP_乗算') {
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = (1 / (1 + HP_乗算 / 100)) / 100;
      return Math.floor(currentDamage * HPincr * hpValue);
    }
    if (key === '体力') {
      const 体力_乗算 = stats.体力_乗算;
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = 7 * (1 + 体力_乗算 / 100) * (1 + HP_乗算 / 100) / HP;
      return Math.floor(currentDamage * HPincr * hpValue);
    }
    if (key === '体力_乗算') {
      const 体力 = (stats.体力) / (1 + (stats.体力_乗算) / 100);
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = 体力 * 0.01 * 7 * (1 + HP_乗算 / 100) / HP;
      return Math.floor(currentDamage * HPincr * hpValue);
    }

    // 通常のステータス増加価値計算
    // 元データを変更しないよう stats をコピー
    const tmp = JSON.parse(JSON.stringify(inputs.value.stats));

    if (key === '攻撃_乗算') {
      // 攻撃_乗算の特殊処理: 攻撃最大と攻撃最小の両方に影響
      const 乗算値 = tmp[key];
      ['攻撃最大', '攻撃最小'].forEach(attackKey => {
        const 補正前値 = tmp[attackKey] / (1 + 乗算値 / 100);
        tmp[attackKey] = 補正前値 * (1 + (乗算値 + 1) / 100);
      });
    } else if (key.endsWith('_乗算')) {
      // 乗算項目: 対応する補正前値に％増加を適用
      const baseKey = key.replace('_乗算', '');
      const actualKey = getActualKey(baseKey);
      const 乗算値 = tmp[key];
      const 表示値 = tmp[actualKey];
      const 補正前値 = 表示値 / (1 + 乗算値 / 100);
      tmp[actualKey] = 補正前値 * (1 + (乗算値 + 1) / 100);
    } else if (key === '攻撃最大' || key === '攻撃最小') {
      tmp[key] += 1 + tmp.攻撃_乗算 / 100;
    } else if (key.endsWith('貫通')) {
      tmp[key] = 100 - (100 - tmp[key]) * 0.99;
    } else {
      // その他のキー
      const actualKey = getActualKey(key);
      const multiplierKey = mulKey(key);
      tmp[actualKey] ++;
      if (multiplierKey in tmp) {
        tmp[actualKey] += tmp[multiplierKey] / 100;
      }  
    }
    const newDamageResult = calculateDamages(tmp);
    return Math.floor(newDamageResult.damage - currentDamage);
  };

  // damagePerStatオブジェクトを作成（ステータス1ポイントあたりのダメージ増加値）
  const damagePerStat = {};
  Object.keys(stats).forEach(key => {
    damagePerStat[key] = damagePerStatPoint(key);
  });

  // 結果オブジェクトを構築
  return {
    baseDamage: baseResults.baseDamage,
    criRate: baseResults.criRate,
    criDamage: baseResults.criDamage,
    damage: baseResults.damage,
    dps: baseResults.dps,
    damagePerStat: damagePerStat
  };
}

/**
 * 基本値計算（％補正前の値）
 * @param {string} key - ステータスキー（プレフィックスなし）
 * @param {object} stats - ステータスオブジェクト
 */
function base(key, stats = inputs.value.stats) {
  
  // 攻撃最大/最小の特殊処理
  if (key === '攻撃最大' || key === '攻撃最小') {
    const 乗算値 = stats.攻撃_乗算;
    return (stats[key]) / (1 + 乗算値 / 100);
  }
  
  const actualKey = getActualKey(key);
  const 表示値 = stats[actualKey];
  const 乗算キー = key + '_乗算';
  
  if (stats[乗算キー] !== undefined) {
    const 乗算値 = stats[乗算キー];
    return 表示値 / (1 + 乗算値 / 100);
  }
  return 表示値;
}

// 物理魔法プレフィックス付きキーを試す
const getActualKey = (key) => {
  const prefixedKey = `${inputs.value.攻撃タイプ}_${key}`;
  // stats内でプレフィックス付きキーが存在すればそれを、なければ基本キーを返す
  return prefixedKey in inputs.value.stats ? prefixedKey : key;
}
 
/**
 * データローダー
 * JSONファイルから各種マスターデータを読み込み
 * 選択連動処理を管理
 */

// スキルデータ読み込み（JSON形式に変更済み）
async function loadSkills() {
  try {
    const response = await fetch('data/skills.json');
    const skillsData = await response.json();
    スキルマスター.value = skillsData;
    
    // 職業リストを生成（重複排除）
    const jobs = new Set();
    skillsData.forEach(skill => {
      if (skill.職業) jobs.add(skill.職業);
    });
    職業リスト.value = Array.from(jobs).sort();
    
    return true;
  } catch (error) {
    console.error('Failed to load skills:', error);
    return false;
  }
}

// 敵データ読み込み
async function loadEnemies() {
  try {
    const response = await fetch('data/enemies.json');
    const enemiesData = await response.json();
    敵マスター.value = enemiesData;
    
    // ダンジョンリストを生成（dungeon.nameを使用）
    const dungeonList = [];
    for (const levelKey in enemiesData) {
      if (enemiesData[levelKey].dungeon && enemiesData[levelKey].dungeon.name) {
        dungeonList.push({
          level: levelKey,
          name: enemiesData[levelKey].dungeon.name
        });
      }
    }
    // レベル順でソート
    dungeonList.sort((a, b) => parseInt(a.level) - parseInt(b.level));
    ダンジョンリスト.value = dungeonList;
    
    return true;
  } catch (error) {
    console.error('Failed to load enemies:', error);
    return false;
  }
}

// 超越スキルデータ読み込み
async function loadTranscendSkills() {
  try {
    const response = await fetch('data/transcend_skills.json');
    const transcendData = await response.json();
    超越スキルマスター.value = transcendData;
    return true;
  } catch (error) {
    console.error('Failed to load transcend skills:', error);
    return false;
  }
}

// ギルドスキルデータ読み込み
async function loadGuildSkills() {
    const response = await fetch('data/guild_skills.json');
    const rawData = await response.json();
    
    // データ形式を変換（各レベルごとのエントリを統合）
    const transformedData = rawData.map(item => {
      // グレードを名前から抽出
      let grade = '初級';
      if (item.skill_name.includes('[中級]')) grade = '中級';
      else if (item.skill_name.includes('[上級]')) grade = '上級';
      
      // スキル名はそのまま使用（グレード表示を含む）
      
      return {
        id: item.skill_id,
        name: item.skill_name,
        grade: grade,
        level: item.level,
        status_type: item.status_type,
        val: item.base_value,
        cost: item.cost
      };
    });
    
    ギルドスキルマスター.value = transformedData;
    return true;
}

// ペットパッシブデータ読み込み
async function loadPetPassives() {
    const response = await fetch('data/pet_passives.json');
    const rawData = await response.json();
    
    // データ形式を変換（descriptionをそのまま使用）
    const transformedData = rawData.map(item => ({
      id: item.id,
      name: item.name,
      skill_type_name: item.skill_type_name,  // スキルタイプ名を追加
      description: item.description,
      status_type1: item.status_type1,
      status_value1: item.status_value1,
      status_type2: item.status_type2,
      status_value2: item.status_value2
    }));
    
    ペットパッシブマスター.value = transformedData;
    return true;
}

// 全データ一括読み込み
async function loadAllData() {
  const results = await Promise.all([
    loadSkills(),
    loadEnemies(),
    loadTranscendSkills(),
    loadGuildSkills(),
    loadPetPassives()
  ]);
  
  const success = results.every(r => r === true);
  
  if (!success) {
    console.error('Some data failed to load');
  }
  
  return success;
}

// 選択可能オプション更新（選択連動処理の統一関数）
function updateSelectableOptions() {
  // 職業が選択されている場合、スキルリストを更新
  if (職業.value) {
    const availableSkills = スキルマスター.value.filter(skill => 
      skill.職業 === 職業.value
    );
    選択可能スキル.value = availableSkills;
  } else {
    選択可能スキル.value = [];
  }
  
  // ダンジョンが選択されている場合、敵リストを更新
  // ダンジョンリストから選択されたダンジョンのレベルを取得
  const selectedDungeonData = ダンジョンリスト.value.find(d => d.name === ダンジョン.value);
  if (selectedDungeonData) {
    const levelKey = selectedDungeonData.level;
    const dungeonData = 敵マスター.value[levelKey];
    if (dungeonData && dungeonData.enemies) {
      // enemies配列から敵の名前リストを取得
      const enemies = dungeonData.enemies.map(enemy => enemy.name);
      選択可能敵.value = enemies;
    } else {
      選択可能敵.value = [];
    }
  } else {
    選択可能敵.value = [];
  }
  
  // 敵が選択されている場合、難易度リストを更新
  if (selectedDungeonData && 敵名.value) {
    const levelKey = selectedDungeonData.level;
    const dungeonData = 敵マスター.value[levelKey];
    if (dungeonData && dungeonData.enemies) {
      // 選択された敵を探す
      const selectedEnemy = dungeonData.enemies.find(e => e.name === 敵名.value);
      if (selectedEnemy && selectedEnemy.difficultyStats) {
        const difficulties = Object.keys(selectedEnemy.difficultyStats);
        選択可能難易度.value = difficulties;
      } else {
        選択可能難易度.value = [];
      }
    } else {
      選択可能難易度.value = [];
    }
  } else {
    選択可能難易度.value = [];
  }
}

// 選択中のスキルデータ取得
function getSelectedSkillData() {
  if (!スキル名.value) return null;
  
  return スキルマスター.value.find(skill => 
    skill.スキル名 === スキル名.value && skill.職業 === 職業.value
  ) || null;
}

// 選択中の敵データ取得
function getSelectedEnemyData() {
  if (!ダンジョン.value || !敵名.value || !難易度.value) {
    return null;
  }
  
  // ダンジョンリストから選択されたダンジョンのレベルを取得
  const selectedDungeonData = ダンジョンリスト.value.find(d => d.name === ダンジョン.value);
  if (!selectedDungeonData) return null;
  
  const levelKey = selectedDungeonData.level;
  const dungeonData = 敵マスター.value[levelKey];
  if (!dungeonData || !dungeonData.enemies) return null;
  
  // 選択された敵を探す
  const selectedEnemy = dungeonData.enemies.find(e => e.name === 敵名.value);
  if (!selectedEnemy) return null;
  
  // 難易度別のステータスを取得
  const difficultyData = selectedEnemy.difficultyStats[難易度.value];
  if (!difficultyData) return null;
  
  // 基本ステータスと難易度別ステータスを統合して返す
  return {
    type: selectedEnemy.type,
    defense: selectedEnemy.baseStats.defense,
    luck: selectedEnemy.baseStats.luck,
    dmgReduce: difficultyData.dmgReduce,
    dmgReduceRatio: difficultyData.dmgReduceRatio,
    critReduce: difficultyData.critReduce
  };
}

// グローバル公開（window.不要、トップレベル関数はそのままアクセス可能）
 
// ランキング計算関数

// StatusTypeマッピング（表示用）
const StatusTypeMap = {
  // HP系
  30: 'HP',
  31: 'HP%',
  
  // ステータス系
  14: '筋力',
  15: '筋力%',
  22: '魔力',
  23: '魔力%',
  26: '体力',
  18: '幸運',
  455: '全ステータス',
  456: '全ステータス%',
  594: '筋力魔力',
  595: '筋力魔力%',
  
  // ダメージ系
  461: '最大',
  462: '最小',
  95: '最終最大',
  103: '最終最大',
  91: '最終最小',
  99: '最終最小',
  590: '最終最小',
  591: '最終最大',
  
  // クリティカル系
  464: 'クリダメ',
  465: 'クリ率',
  157: '最終クリダメ',
  163: '最終クリダメ',
  592: '最終クリダメ',
  
  // 追加ダメージ系
  496: '追加ダメ',
  141: '追加ダメ%',
  241: '追加ダメ%',
  588: '追加ダメ%',
  566: '一般追加ダメ',
  570: 'ボス追加ダメ',
  573: '一般支配',
  574: 'ボス支配',
  
  // 属性系
  492: '属性',
  38: '属性',
  493: '属性%',
  39: '属性%',
  586: '属性',
  587: '属性%',
  
  // その他
  463: '貫通',
  216: '防御',
  70: '抵抗力',
  596: '防御抵抗',
  495: 'ダメージ減少',
  86: 'ダメージ減少%',
  440: 'CT',
  106: '移動速度',
  466: '命中率',
  494: 'バックアタック',
  567: '一般追加ダメ%',
  571: 'ボス追加ダメ%',
  208: '筋力効率',
  200: '魔力効率',
  614: 'スキルターゲット数',
  128: 'Ely獲得量',
  132: 'アイテムドロップ率',
  488: 'クエスト報酬',
  124: '経験値',
  
  // 追加されたstatusType
  19: '体力/幸運(%)',
  27: '体力/幸運(%)',
  94: '物理最大ダメージA',
  102: '魔法最大ダメージA',
  144: '物理ダメージ減少A',
  458: '魔法抵抗力',
  497: '回避率A',
  584: '超人ポイントA',
  585: '最小/最大ダメージA'
};

// スキル名の省略形変換マップ
const skillNameAbbreviations = {
  'クリティカルダメージ': 'クリダメ',
  'ダメージ減少': 'ダメ減',
  '一般モンスター追加ダメージ': '一般追加ダメ',
  'ボスモンスター追加ダメージ': 'ボス追加ダメ',
  'バックアタックダメージ': 'BA',
  '一般モンスター支配力': '一般支配',
  'ボスモンスター支配力': 'ボス支配',
  'クールタイム減少': 'CT減少',
  '筋力、魔法力': '筋魔',
  '物理/魔法追加ダメージ': '追加ダメ',
  '全ステータス': '全ステ',
  '武器属性力': '属性',
  '最大HP': 'HP',
  '最小ダメージ': '最小',
  '最大ダメージ': '最大',
  '筋力/魔力効率': '効率',
  'スキルターゲット数': 'タゲ数',
  '移動速度': '移動'
};

// スキル名を短縮形に変換
function shortenSkillName(name) {
  let shortened = name;
  for (const [full, short] of Object.entries(skillNameAbbreviations)) {
    shortened = shortened.replace(full, short);
  }
  // その他の簡略化
  shortened = shortened.replace(/\s*\(\+\)\s*/g, '');
  shortened = shortened.replace(/\s*\(%\)\s*/g, '%');
  shortened = shortened.replace(/\s*-\s*/g, '-');
  shortened = shortened.replace(/\\n/g, '/');
  shortened = shortened.replace('Ⅰ', '1');
  shortened = shortened.replace('Ⅱ', '2');
  return shortened;
}

// ダメージ換算
function calculateDamageIncrease(statusType, value) {
  const damagePerStat = results.value.damagePerStat;
  
  // HP系
  if (statusType === 30) return damagePerStat['HP'] * value;
  if (statusType === 31) return damagePerStat['HP_乗算'] * value;
  
  // ステータス系
  if (statusType === 14) return damagePerStat['筋力'] * value;
  if (statusType === 15) return damagePerStat['筋力_乗算'] * value;
  if (statusType === 22) return damagePerStat['魔力'] * value;
  if (statusType === 23) return damagePerStat['魔力_乗算'] * value;
  if (statusType === 26) return damagePerStat['体力'] * value;
  if (statusType === 18) return damagePerStat['幸運'] * value;
  
  // 全ステータス
  if (statusType === 455) {
    return value * (damagePerStat['筋力'] + damagePerStat['体力'] + damagePerStat['幸運'] + damagePerStat['魔力']);
  }
  if (statusType === 456) {
    return value * (damagePerStat['筋力_乗算'] + damagePerStat['体力_乗算'] + damagePerStat['幸運_乗算'] + damagePerStat['魔力_乗算']);
  }
  
  // 筋力魔力（より高い方を採用）
  if (statusType === 594) {
    return value * Math.max(damagePerStat['筋力'], damagePerStat['魔力']);
  }
  if (statusType === 595) {
    return value * Math.max(damagePerStat['筋力_乗算'], damagePerStat['魔力_乗算']);
  }
  
  // ダメージ系
  if (statusType === 461) return damagePerStat[getActualKey('最大')] * value;
  if (statusType === 462) return damagePerStat[getActualKey('最小')] * value;
  
  // 最終系ダメージ
  if ([95, 591].includes(statusType)) {
    // 最終最大（103は重複のため除外）
    return damagePerStat['最終最大'] * value;
  }
  if ([91, 590].includes(statusType)) {
    // 最終最小（99は重複のため除外）
    return damagePerStat['最終最小'] * value;
  }
  
  // 重複マッピングは無効化（103, 99, 163, 241, 39）
  if ([103, 99, 163, 241, 39].includes(statusType)) {
    return 0;  // not calc
  }
  
  // クリティカル系
  if (statusType === 464) return damagePerStat[getActualKey('クリダメ')] * value;
  if (statusType === 465) return damagePerStat[getActualKey('クリ率')] * value;
  if ([157, 592].includes(statusType)) {
    // 最終クリダメ（163は重複のため除外）
    return damagePerStat['最終クリダメ'] * value;
  }
  
  // 追加ダメージ系
  if (statusType === 496) return damagePerStat[getActualKey('追加ダメ')] * value;
  if ([141, 588].includes(statusType)) {
    // 追加ダメ%（241は重複のため除外）
    return damagePerStat['追加ダメ_乗算'] * value;
  }
  if (statusType === 566) return damagePerStat['一般追加ダメ'] * value;
  if (statusType === 570) return damagePerStat['ボス追加ダメ'] * value;
  if (statusType === 567) return damagePerStat['一般追加ダメ_乗算'] * value;
  if (statusType === 571) return damagePerStat['ボス追加ダメ_乗算'] * value;
  if (statusType === 573) return damagePerStat['一般支配'] * value;
  if (statusType === 574) return damagePerStat['ボス支配'] * value;
  
  // 武器属性力の特殊処理
  if ([492, 38, 586].includes(statusType)) {
    // 武器属性力(+) = 攻撃最大 + 攻撃最小 + 属性
    return value * (damagePerStat['攻撃最大'] + damagePerStat['攻撃最小'] + damagePerStat['属性']);
  }
  if ([493, 587].includes(statusType)) {
    // 武器属性力(%) = 攻撃% + 属性%（39は重複のため除外）
    return value * (damagePerStat['攻撃_乗算'] + damagePerStat['属性_乗算']);
  }
  
  // その他
  if (statusType === 463) return damagePerStat[getActualKey('貫通')] * value;
  // if (statusType === 106) return damagePerStat['移動'] * value;
  // if (statusType === 466) return damagePerStat['命中率'] * value;
  
  // 効率系（暫定で計算不可）
  if ([/* 208, */200].includes(statusType)) return damagePerStat['効率'] * value;
  
  // その他計算不可
  return 0;
}

// 入力値のハッシュを生成（変更検出用）
function generateInputHash(stats) {
  const keys = ['str', 'vit', 'int', 'magic', 'agi', 'attrFire', 'attrWater', 'attrLight', 'attrWind'];
  return keys.map(k => stats[k]).join(',');
}

// 超越1ランキング計算
function calculateTranscend1Rankings() {
  const skills = 超越スキルマスター.value;
  const transcend1Skills = skills.filter(skill => skill.position <= 3);
  
  return calculateRankings(transcend1Skills);  // レベル表示なし
}

// 超越2ランキング計算（列ごと）
function calculateTranscend2ColumnRankings() {
  const skills = 超越スキルマスター.value;
  const transcend2Skills = [[],[],[]];
  
  skills.forEach(skill => {
    if(skill.position >= 4) {
      transcend2Skills[skill.position - 4].push(skill);
    }
  });
  
  return transcend2Skills.map(s => calculateRankings(s));
}

// 効果文字列生成ヘルパー
function buildEffectString(statusType, value) {
  
  // 特殊ケースの名前変換
  const specialNames = {
    455: '全ステ', 456: '全ステ%',
    594: '筋魔', 595: '筋魔%',
    492: '武器属性', 38: '武器属性', 586: '武器属性',
    493: '武器属性%', 39: '武器属性%', 587: '武器属性%'
  };
  
  const statName = specialNames[statusType] || StatusTypeMap[statusType];

  // パーセント系の処理
  const isPercent = statName.endsWith('%');
  const displayName = isPercent ? statName.slice(0, -1) : statName;
  
  // 符号処理: 正の数には+を付け、負の数はそのまま（既に-が付いている）
  const sign = value > 0 ? '+' : '';
  return `${displayName}${sign}${value}${isPercent ? '%' : ''}`;
}

/* 
[{
cost_per_level, 
max_level, 
status_value_slv1, 
skill.status_value1, 
status_type1,  
status_value1,
status_type2,  
status_value2
}]
*/
const calculateRankings = skills => {
  const rankings = [];
  
  for (const skill of skills) {
    // 固定コストならループは1回、可変コストならmax_level回
    const maxIterations = skill.cost_per_level === 0 ? 1 : skill.max_level;
    
    for (let level = 1; level <= maxIterations; level++) {
      // このレベルでの実際の値を計算
      let totalDamageIncrease = 0;
      const effects = [];
      
      const value1 = skill.status_value_slv1 + skill.status_value1 * (level - 1);
      const value2 = skill.status_type2 > 0 ? skill.status_value_slv2 + skill.status_value2 * (level - 1) : 0;
      
      // 筋力効率と魔力効率が同じ値の場合は「効率」として表示
      if ((skill.status_type1 === 208 && skill.status_type2 === 200) || 
          (skill.status_type1 === 200 && skill.status_type2 === 208)) {
        if (value1 !== value2) {
          throw new Error('筋力魔力効率が異なる');
        }
        totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
        totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value1);
        effects.push(`効率+${value1}`);
      }
      // 筋力%と魔力%が同じ値の場合は「筋魔%」として表示
      else if ((skill.status_type1 === 15 && skill.status_type2 === 23) || 
          (skill.status_type1 === 23 && skill.status_type2 === 15)) {
        if (value1 !== value2) {
          throw new Error('筋力魔力効%が異なる');
        }
        totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
        totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value2);
        effects.push(`筋魔+${value1}%`);
      }
      // 筋力と魔力（値のみ）が同じ値の場合は「筋魔」として表示
      else if ((skill.status_type1 === 14 && skill.status_type2 === 22) || 
               (skill.status_type1 === 22 && skill.status_type2 === 14)) {
        if (value1 !== value2) {
          throw new Error('筋力魔力効が異なる');
        }
          totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
          totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value2);
          effects.push(`筋魔+${value1}`);
      }
      // その他の場合は通常通り処理
      else {
        if (value1 !== 0) {
          totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
          const effect1 = buildEffectString(skill.status_type1, value1);
          effects.push(effect1);
        }
        
        if (skill.status_type2 > 0 && value2 !== 0) {
          totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value2);
          const effect2 = buildEffectString(skill.status_type2, value2);
          effects.push(effect2);
        }
      }
      
      const cost = skill.base_cost + (level - 1) * skill.cost_per_level;
      const valuePerPoint = totalDamageIncrease / cost;
      
      if (valuePerPoint > 0) {
        rankings.push({
          id: skill.id,
          name: skill.name,
          position: skill.position,
          level: skill.cost_per_level > 0 ? level : '*',
          effects: [...new Set(effects)].join(skill.position == 5 ? '<br>' : ', '),
          cost: cost,
          damageIncrease: Math.floor(totalDamageIncrease),
          costPerPoint: Math.floor(valuePerPoint),
          isFixedCost: skill.cost_per_level === 0,
        });
      }
    }
  }
  
  return rankings.sort((a, b) => b.costPerPoint - a.costPerPoint).slice(0, 1000);
}

// ギルドスキルランキング計算（全グレード）
function calculateGuildSkillRankings() {
  const skills = ギルドスキルマスター.value;
  const rankings = [];
  
  for (const skill of skills) {
    
    const dmg = calculateDamageIncrease(skill.status_type, skill.val);
    if (dmg <= 0) continue;
    
    const costPerPoint = skill.cost > 0 ? dmg / skill.cost : 0;
    
    // effectをbuildEffectStringで構築
    const effect = buildEffectString(skill.status_type, skill.val);
    
    rankings.push({
      key: `${skill.name}_${skill.grade}_${skill.level}`,  // ユニークキーを追加
      name: skill.name,
      grade: skill.grade,
      level: skill.level,  // レベルを追加
      effect: effect,  // statusTypeの代わりにeffectを使用
      value: skill.val,
      cost: skill.cost,
      damage: isNaN(dmg) ? 0 : Math.round(dmg),
      costPerPoint: isNaN(costPerPoint) ? 0 : Math.round(costPerPoint * 100) / 100
    });
  }
  
  // ソート時にNaNや無効値を考慮
  return rankings.sort((a, b) => {
    if (a.costPerPoint > 0 && b.costPerPoint > 0) {
      return b.costPerPoint - a.costPerPoint;
    }
    if (a.costPerPoint <= 0 && b.costPerPoint > 0) {
      return 1;
    }
    if (b.costPerPoint <= 0 && a.costPerPoint > 0) {
      return -1;
    }
    return 0;
  });
}

// ペットパッシブランキング計算
function calculatePetPassiveRankings() {
  const skills = ペットパッシブマスター.value;
  
  const rankings = [];
  
  for (const skill of skills) {
    // 各ステータスタイプのダメージを計算
    let totalDamage = 0;
    const effects = [];
    
    // status_type1のeffectを構築
    if (skill.status_type1 && skill.status_value1) {
      const dmg1 = calculateDamageIncrease(skill.status_type1, skill.status_value1);
      totalDamage += dmg1;
      effects.push(buildEffectString(skill.status_type1, skill.status_value1));
    }
    
    // status_type2のeffectを構築
    if (skill.status_type2 && skill.status_value2) {
      const dmg2 = calculateDamageIncrease(skill.status_type2, skill.status_value2);
      totalDamage += dmg2;
      effects.push(buildEffectString(skill.status_type2, skill.status_value2));
    }
    
    // effectsを改行で結合
    const effectString = effects.join(',');
    
    // スコア0でも表示するため、すべて追加
    rankings.push({
      id: skill.id,
      name: skill.name,
      skillType: skill.skill_type_name,  // スキルタイプを追加
      effect: effectString,
      damage: Math.round(totalDamage)
    });
  }

  sorted = rankings.sort((a, b) => b.damage - a.damage);
  
  return sorted;
}
 
// Vue 3 最小限実装 - computedのみ使用（refはstore.jsで定義済み）

const { createApp, computed } = Vue;

// === computed チェーン（職業 → スキル） ===
const 選択中スキル = computed(() => {
  if (!スキル名.value || !スキルマスター.value) return null;
  return スキルマスター.value.find(skill =>
    skill.職業 === 職業.value && skill.スキル名 === スキル名.value
  );
});

// スキル倍率を更新する関数（computedではなく直接更新）
const updateSkillValues = () => {
  const skill = 選択中スキル.value;
  if (!skill) {
    return;
  }

  const level = スキルレベル.value;
  const skillPower = skill.係数初期値;
  const powerPerLevel = skill.係数上昇値;
  const baseDamage = skill.固定ダメージ初期値;
  const damagePerLevel = skill.固定ダメージ上昇値;

  // inputs.valueに直接セット
  inputs.value.スキル倍率 = skillPower + (powerPerLevel * (level - 1));
  inputs.value.スキル追加ダメ = baseDamage + (damagePerLevel * (level - 1));
  inputs.value.モーション時間 = skill.モーション時間 || 1;
  inputs.value.ヒット数 = skill.ヒット数 || null;

  // スキルタイプに応じて攻撃タイプとスキルタイプを設定
  if (skill.物理or魔法) {
    inputs.value.攻撃タイプ = skill.物理or魔法;
  }
  if (skill.スキルタイプ) {
    inputs.value.スキルタイプ = skill.スキルタイプ;
  }
};

// 敵ステータスを更新する関数（computedではなく直接更新）
const updateEnemyValues = () => {
  if (!ダンジョン.value || !敵名.value || !敵マスター.value) {
    return;
  }

  // ダンジョンリストから選択されたダンジョンのレベルを取得
  const selectedDungeonData = ダンジョンリスト.value.find(d => d.name === ダンジョン.value);
  if (!selectedDungeonData) return;

  const levelKey = selectedDungeonData.level;
  const dungeonData = 敵マスター.value[levelKey];
  if (!dungeonData || !dungeonData.enemies) return;

  // 選択された敵を探す
  const selectedEnemy = dungeonData.enemies.find(e => e.name === 敵名.value);
  if (!selectedEnemy) return;

  // 敵タイプを設定
  inputs.value.敵タイプ = selectedEnemy.type;

  // baseStatsから基本値を設定
  inputs.value.敵防御 = selectedEnemy.baseStats?.defense;
  inputs.value.敵幸運 = selectedEnemy.baseStats?.luck;

  // 難易度が選択されている場合は難易度別のステータスを設定
  if (難易度.value) {
    const difficultyData = selectedEnemy.difficultyStats?.[難易度.value];
    if (difficultyData) {
      inputs.value.敵ダメ減 = difficultyData.dmgReduce;
      inputs.value.敵ダメ減_乗算 = difficultyData.dmgReduceRatio;
      inputs.value.敵クリ減 = difficultyData.critReduce;
    }
  }
};

// === イベントハンドラ（シンプル化） ===
const onJobChange = () => {
  スキル名.value = '';  // スキル選択をリセット
};

const onSkillChange = () => {
  const skill = 選択中スキル.value;
  if (skill) {
    スキルレベル.value = skill.最大レベル;
    updateSkillValues();  // スキル値を更新
  }
};

const onSkillLevelChange = () => {
  updateSkillValues();  // スキルレベル変更時も更新
};

const onDungeonChange = () => {
  難易度.value = '';  // 難易度選択をリセット
  敵名.value = '';  // 敵選択をリセット
};

const onDifficultyChange = () => {
  // 難易度変更時に敵ステータスを更新
  updateEnemyValues();
};

const onEnemyChange = () => {
  // 敵変更時に敵ステータスを更新
  updateEnemyValues();
};


// === 最終的なダメージ計算（全ての依存関係を統合） ===
const results = computed(() => {
  // calculateResultsはinputs.valueを直接参照するので、そのまま呼び出す
  const calcResults = calculateResults();

  // 計算後に毎回localStorageに保存（シンプルな実装）
  saveToStorage();

  return calcResults;
});

// === ギルドスキルランキング（トップレベルで定義） ===
const allGuildSkillRankings = computed(() => {
  return calculateGuildSkillRankings();
});

// アプリケーション作成
const app = createApp({
  setup() {
    // setup開始時にlocalStorageから復元（シンプルな実装）
    const restored = loadFromStorage();
    if (restored) {
      // 選択系の値が復元された場合、関連する更新を実行
      if (スキル名.value) {
        updateSkillValues();
      }
      if (敵名.value && 難易度.value) {
        updateEnemyValues();
      }
    }

    // === 選択可能オプション（computed） ===
    const 選択可能スキルComputed = computed(() => {
      if (!職業.value || !スキルマスター.value) return [];
      return スキルマスター.value.filter(skill => skill.職業 === 職業.value);
    });

    const 選択可能難易度Computed = computed(() => {
      if (!ダンジョン.value || !ダンジョンリスト.value) return [];

      const selectedDungeonData = ダンジョンリスト.value.find(d => d.name === ダンジョン.value);
      if (!selectedDungeonData) return [];

      const levelKey = selectedDungeonData.level;
      const dungeonData = 敵マスター.value[levelKey];
      if (!dungeonData || !dungeonData.enemies) return [];

      // 最初の敵の難易度一覧を取得（全敵共通）
      const firstEnemy = dungeonData.enemies[0];
      if (!firstEnemy || !firstEnemy.difficultyStats) return [];

      return Object.keys(firstEnemy.difficultyStats).sort((a, b) => Number(a) - Number(b));
    });

    const 選択可能敵Computed = computed(() => {
      if (!ダンジョン.value || !難易度.value || !ダンジョンリスト.value) return [];

      const selectedDungeonData = ダンジョンリスト.value.find(d => d.name === ダンジョン.value);
      if (!selectedDungeonData) return [];

      const levelKey = selectedDungeonData.level;
      const dungeonData = 敵マスター.value[levelKey];
      if (!dungeonData || !dungeonData.enemies) return [];

      // 選択された難易度のデータを持つ敵だけ返す（全部のはず）
      return dungeonData.enemies
        .filter(enemy => enemy.difficultyStats && enemy.difficultyStats[難易度.value])
        .map(enemy => enemy.name);
    });
    
    // 初期化時に全データを読み込み
    loadAllData().then(success => {
      if (!success) {
        console.error('データ読み込みに失敗しました');
      }
    });

    return {
      results,
      
      // store.jsで定義済みのトップレベル変数
      職業,
      スキル名,
      ダンジョン,
      敵名,
      難易度,
      スキルレベル,
      最大スキルレベル,
      inputs,
      activeMainTab,
      guildSkillGradeFilters,
      選択可能スキル: 選択可能スキルComputed,
      選択可能敵: 選択可能敵Computed,
      選択可能難易度: 選択可能難易度Computed,
      スキルマスター,
      敵マスター,
      超越スキルマスター,
      ギルドスキルマスター,
      ペットパッシブマスター,
      職業リスト,
      ダンジョンリスト,
      // 計算結果のcomputed値
      results,

      // ヘルパー関数
      base,  // calculator.jsから
      incr: (stat) => results.value.damagePerStat[stat],
      formatDamage: (damage) => {
        const oku = Math.floor(damage / 100000000);
        const man = Math.floor((damage % 100000000) / 10000);
        const remainder = Math.floor(damage % 10000);
        
        return (oku ? oku + '億' : '') + 
               (man ? man + '万' : '') + 
               remainder;
      },

      // ステータスのキー配列を返すcomputed
      statKeys: computed(() => {
        const allStats = Object.keys(inputs.value.stats);
        return allStats.filter(s => {
          // _乗算で終わるものは除外
          if (s.endsWith('_乗算')) return false;

          if (s.startsWith('一般') && inputs.value.敵タイプ === 'ボス'
            || s.startsWith('ボス') && inputs.value.敵タイプ !== 'ボス') {
            return false;
          }

          // 物理タブの場合、魔法・属性系を除外
          if (inputs.value.攻撃タイプ === '物理') {
            return !(s.startsWith('魔') || s.startsWith('属'));
          }
          // 魔法タブの場合、筋力・物理・攻撃系を除外
          else {
            return !(s.startsWith('筋') || s.startsWith('物') || s.startsWith('攻'));
          }
        });
      }),
      isPhysical: computed(() => inputs.value.攻撃タイプ === '物理'),
      label: stat => {
        const withoutPrefix = stat.replace(/^(物理|魔法)_/, '');
        if (withoutPrefix.endsWith('乗算')) {
          const withoutSuffix = withoutPrefix.replace(/_乗算$/, '');
          return ['クリダメ', '最大', '最小'].includes(withoutSuffix) ? '最終' : '%';
        }
        return withoutPrefix;
      },
      mulKey,
      hasMultiplier: stat => mulKey(stat) in inputs.value.stats,

      currentSkillMaxLevel: 20,
      dpsCards: [],
      
      // ランキング計算のキャッシュ用（refで定義）
      rankingInputHash: ref(''),
      
      // 超越1ランキング
      transcend1Headers: [
        { label: '順位', align: 'text-left' },
        { label: 'カテゴリ', align: 'text-left' },
        { label: 'スキル名', align: 'text-left' },
        { label: 'Lv', align: 'text-center' },
        { label: 'コスト', align: 'text-right' },
        { label: 'ダメ換算/P', align: 'text-right' }
      ],
      transcend1Rankings: computed(() => {
        const rankings = calculateTranscend1Rankings();
        return rankings;
      }),
      
      transcend2Headers: [
        { label: '順位', align: 'text-left' },
        { label: 'スキル名', align: 'text-left' },
        { label: 'Lv', align: 'text-center' },
        { label: '消費P', align: 'text-right' },
        { label: 'ダメ換算/P', align: 'text-right' }
      ],
      
      // 3つのカラムのランキングを配列として管理
      transcend2Rankings: computed(() => {
        // calculateTranscend2ColumnRankingsはパラメータを取らない
        return calculateTranscend2ColumnRankings();
      }),
      
      // ペットパッシブランキング
      petPassiveHeaders: [
        { label: '順位', align: 'text-left' },
        { label: 'ペット名', align: 'text-left' },
        { label: 'スキルタイプ', align: 'text-left' },
        { label: 'ステータス', align: 'text-left' },
        { label: 'ダメ換算', align: 'text-right' }
      ],
      filteredPetPassiveRankings: computed(() => {
        if (activeMainTab.value !== 'petPassive') return [];
        
        const rankings = calculatePetPassiveRankings();
        
        return rankings;
      }),
      
      // ギルドスキルランキング
      guildSkillHeaders: [
        { label: '順位', align: 'text-left' },
        { label: 'スキル名', align: 'text-left' },
        { label: 'ステータス', align: 'text-left' },
        { label: 'Lv', align: 'text-right' },
        { label: 'コスト', align: 'text-right' },
        { label: 'ダメ換算/P', align: 'text-right' }
      ],
      guildSkillGradeOptions: ['初級', '中級', '上級'],
      allGuildSkillRankings,  // トップレベルで定義したものを参照
      
      // フィルタ済みギルドスキルランキング（allGuildSkillRankingsとフィルタに依存）
      filteredGuildSkillRankings: computed(() => {
        // フィルタが変更された時のみ再計算される（全体の再計算はしない）
        const allRankings = allGuildSkillRankings.value;
        
        // オブジェクトから選択されたグレードの配列を作成
        const selectedGrades = Object.entries(guildSkillGradeFilters.value)
          .filter(([_, enabled]) => enabled)
          .map(([grade, _]) => grade);
        
        // 全グレード選択または選択なしの場合は全て表示
        if (selectedGrades.length === 0 || selectedGrades.length === 3) {
          return allRankings;
        }
        
        // 選択されたグレードのみフィルタリング
        return allRankings.filter(skill => selectedGrades.includes(skill.grade));
      }),
      selectedSkillTitle: '',
      currentSkillType: '',

      // メソッド
      triggerCalculation: () => { },
      onJobChange,
      onSkillChange,
      onSkillLevelChange,
      onDungeonChange,
      onEnemyChange,
      onDifficultyChange,
      isLastCheckedGuildGrade: () => false,
      isLastCheckedPetPriority: () => false
    };
  }
});

// アプリケーションをマウント
app.mount('#app');
