/**
 * グローバル単一データストア
 * DRY原則: 同一データは1箇所でのみ管理
 * リアクティビティ粒度を適切に制御するため、変更時の挙動単位でrefを分離
 */

const { ref } = Vue;

// スキル複数管理用
const 選択中スキルインデックス = ref(0); // 現在選択中のスキル（ダメージ計算用）
const スキルリスト = ref([
  {
    職業: '',
    スキル名: '',
    レベル: 1,
    タイプ: '攻撃',
    倍率: 100,
    追加ダメ: 0,
    召喚補正: 100,
    HIT数: 1,
    ウェイト: 100,
    有効: true
  }
]);

// 敵選択UIは一般/ボス個別管理（リアクティビティ最適化）
const ダンジョン_一般 = ref('');
const ダンジョン_ボス = ref('');
const 敵名_一般 = ref('');
const 敵名_ボス = ref('');
const 難易度_一般 = ref('');
const 難易度_ボス = ref('');

// 敵ステータス（一般/ボス個別管理）
const 敵ステータス_一般 = ref({
  防御: 1,
  ダメ減: 0,
  ダメ減_乗算: 0,
  幸運: 1068254,
  クリ減: 0
});

const 敵ステータス_ボス = ref({
  防御: 1,
  ダメ減: 0,
  ダメ減_乗算: 0,
  幸運: 1068254,
  クリ減: 0
});

// UI制御
const 敵タブ = ref('ボス');
const ボス重要度 = ref(70);
const 換算方法 = ref('増加ダメ');

const スキルレベル = ref(1);
const 最大スキルレベル = ref(20);

// 現在選択中のスキルデータへのアクセサ（選択中スキルインデックスを使用）
const get現在スキル = () => {
  return スキルリスト.value[選択中スキルインデックス.value] || スキルリスト.value[0];
};

// スキル追加
const addスキルタブ = () => {
  if (スキルリスト.value.length < 10) {
    const 既存職業 = スキルリスト.value[0]?.職業 || '';
    スキルリスト.value.push({
      職業: 既存職業,
      スキル名: '',
      レベル: 1,
      タイプ: '攻撃',
      倍率: 100,
      追加ダメ: 0,
      召喚補正: 100,
      HIT数: 1,
      ウェイト: 100,
      有効: true
    });
    // 新しく追加したスキルを選択
    選択中スキルインデックス.value = スキルリスト.value.length - 1;
  }
};

// スキル削除
const removeスキルタブ = (index) => {
  // 最低1つは残す
  if (スキルリスト.value.length <= 1) {
    return;
  }
  
  // 削除前に選択中インデックスを調整
  if (選択中スキルインデックス.value === index) {
    選択中スキルインデックス.value = index > 0 ? index - 1 : 0;
  } else if (選択中スキルインデックス.value > index) {
    選択中スキルインデックス.value--;
  }
  
  // スキルを削除
  スキルリスト.value.splice(index, 1);
};

const activeMainTab = ref('damage');
const guildSkillGradeFilters = ref({
  初級: true,
  中級: true,
  上級: true
});

// 覚醒ポイント数（ユーザー入力：追加で振るポイント数）
const 覚醒1ポイント = ref(0);
const 覚醒2ポイント = ref(0);

// 覚醒Canvas状態管理
const 覚醒1アクティブノード = ref(new Set());
const 覚醒2アクティブノード = ref(new Set());

// 覚醒累積ポイント数（READ ONLY：現在使用中のポイント数）
const 覚醒1累積ポイント = Vue.computed(() => 覚醒1アクティブノード.value.size);
const 覚醒2累積ポイント = Vue.computed(() => 覚醒2アクティブノード.value.size);
const 覚醒1ロックノード = ref(new Set());
const 覚醒2ロックノード = ref(new Set());
const 覚醒ロックモード = ref(false);

const スキルマスター = ref([]);
const 敵マスター_一般 = ref({});
const 敵マスター_ボス = ref({});
const 超越スキルマスター = ref([]);
const ギルドスキルマスター = ref([]);
const ペットパッシブマスター = ref([]);
const 職業リスト = ref([]);
const ダンジョンリスト_一般 = ref([]);
const ダンジョンリスト_ボス = ref([]);

let 超越1初期化データ = [];
let 超越2_1初期化データ = [];
let 超越2_2初期化データ = [];
let 超越2_3初期化データ = [];
let ギルドスキル初期化データ = [];
let ペットパッシブ初期化データ = [];

const inputs = ref({
  攻撃タイプ: '物理',
  スキルタイプ: '攻撃',
  
  スキル倍率: 100,
  スキル追加ダメ: 0,
  モーション時間: null,
  ヒット数: null,
  
  stats: {
    筋力: 546424,
    筋力_乗算: 316,
    魔力: 546424,
    魔力_乗算: 316,
    効率: 0,
    体力: 400512,
    体力_乗算: 620,
    幸運: 400948,
    幸運_乗算: 300,
    
    HP: 4474100,
    HP_乗算: 217,
      
    攻撃最大: 50000,
    攻撃最小: 50000,
    攻撃_乗算: 100,
    属性: 14382,
    属性_乗算: 276,
    
    物理_クリ率: 50,
    魔法_クリ率: 50,
    物理_クリダメ: 1993,
    魔法_クリダメ: 1993,
    クリダメ_乗算: 0,

    物理_最大: 0,
    魔法_最大: 0,
    最大_乗算: 1310,

    物理_最小: 0,
    魔法_最小: 0,
    最小_乗算: 1473,
  
    基礎最大: 105,
    基礎最小: 95,
    
    属性最大: 0,
    属性最小: 0,

    物理_貫通: 90,
    魔法_貫通: 90,

    物理_追加ダメ: 247784,
    魔法_追加ダメ: 247784,
    追加ダメ_乗算: 110,
    
    一般追加ダメ: 122046,
    一般追加ダメ_乗算: 0,
    一般支配: 17.4,
    ボス追加ダメ: 122046,
    ボス追加ダメ_乗算: 0,
    ボス支配: 17.4,
  },
    
  攻撃補正: 100,
  属性補正: 100,
  ダメ補正: 100,
  
  HPダメージ換算: 100,
  
  経験値: 1243
});

const getCurrentSkillData = () => {
  const currentSkill = get現在スキル();
  if (!currentSkill || !currentSkill.スキル名) return null;
  
  return スキルマスター.value.find(skill => 
    skill.職業 === currentSkill.職業 && skill.スキル名 === currentSkill.スキル名
  ) || null;
};

const deepMerge = (target, source) => {
  if (!source) return target;
  
  for (const key in target) {
    if (key in source) {
      if (typeof target[key] === 'object' && target[key] !== null && 
          typeof source[key] === 'object' && source[key] !== null) {
        deepMerge(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
};

const get選択中ダンジョンデータ = (enemyType) => {
  const dungeonName = enemyType === '一般' ? ダンジョン_一般.value : ダンジョン_ボス.value;
  const dungeonList = enemyType === '一般' ? ダンジョンリスト_一般.value : ダンジョンリスト_ボス.value;
  return dungeonList.find(d => d.name === dungeonName);
};

const get選択中ダンジョン敵データ = (enemyType) => {
  const selectedDungeonData = get選択中ダンジョンデータ(enemyType);
  if (!selectedDungeonData) return null;
  const enemyMaster = enemyType === '一般' ? 敵マスター_一般.value : 敵マスター_ボス.value;
  return enemyMaster[selectedDungeonData.level];
};

const loadFromStorage = () => {
  try {
    const saved = localStorage.getItem('lataleCalcData');
    if (saved) {
      const data = JSON.parse(saved);
      
      // deepMergeで全て処理（存在するものは上書き、存在しないものは無視）
      if (data.inputs) deepMerge(inputs.value, data.inputs);
      // スキルリストは配列なので直接代入
      if (data.スキルリスト && Array.isArray(data.スキルリスト)) {
        スキルリスト.value = data.スキルリスト;
      }
      // 選択中のスキルインデックスも復元
      if (typeof data.選択中スキルインデックス === 'number') {
        選択中スキルインデックス.value = data.選択中スキルインデックス;
      }
      
      // 後方互換性：旧形式から新形式への移行
      if (data.ダンジョン && typeof data.ダンジョン === 'string') {
        ダンジョン_一般.value = data.ダンジョン;
        ダンジョン_ボス.value = data.ダンジョン;
      } else {
        ダンジョン_一般.value = data.ダンジョン_一般 || '';
        ダンジョン_ボス.value = data.ダンジョン_ボス || '';
      }
      
      if (data.敵名 && typeof data.敵名 === 'string') {
        敵名_一般.value = data.敵名;
        敵名_ボス.value = data.敵名;
      } else {
        敵名_一般.value = data.敵名_一般 || '';
        敵名_ボス.value = data.敵名_ボス || '';
      }
      
      if (data.難易度 && typeof data.難易度 === 'string') {
        難易度_一般.value = data.難易度;
        難易度_ボス.value = data.難易度;
      } else {
        難易度_一般.value = data.難易度_一般 || '';
        難易度_ボス.value = data.難易度_ボス || '';
      }
      
      // 敵ステータスの移行
      if (data.inputs && data.inputs.敵ステータス) {
        if (data.inputs.敵ステータス.一般) {
          敵ステータス_一般.value = data.inputs.敵ステータス.一般;
        }
        if (data.inputs.敵ステータス.ボス) {
          敵ステータス_ボス.value = data.inputs.敵ステータス.ボス;
        }
      } else if (data.敵ステータス_一般 && data.敵ステータス_ボス) {
        敵ステータス_一般.value = data.敵ステータス_一般;
        敵ステータス_ボス.value = data.敵ステータス_ボス;
      }
      
      // 重要度の移行
      if (data.inputs && typeof data.inputs.ボス重要度 === 'number') {
        ボス重要度.value = data.inputs.ボス重要度;
      } else if (typeof data.ボス重要度 === 'number') {
        ボス重要度.value = data.ボス重要度;
      }
      
      // 敵タブの移行
      if (data.inputs && data.inputs.敵タブ) {
        敵タブ.value = data.inputs.敵タブ;
      } else if (data.敵タブ) {
        敵タブ.value = data.敵タブ;
      }
      
      スキルレベル.value = data.スキルレベル || 1;
      return true;
    }
  } catch (error) {
    localStorage.removeItem('lataleCalcData');
  }
  return false;
};

// 加重平均計算の共通関数
const calcWeightedAverage = (generalValue, bossValue) => {
  const bossImportance = ボス重要度.value / 100;
  return generalValue * (1 - bossImportance) + bossValue * bossImportance;
};

const saveToStorage = () => {
  try {
    const currentSkill = get現在スキル();
    const data = {
      inputs: inputs.value,
      スキルリスト: スキルリスト.value,
      選択中スキルインデックス: 選択中スキルインデックス.value,
      職業: currentSkill?.職業 || '', // 互換性のため残す
      スキル名: currentSkill?.スキル名 || '', // 互換性のため残す
      ダンジョン_一般: ダンジョン_一般.value,
      ダンジョン_ボス: ダンジョン_ボス.value,
      敵名_一般: 敵名_一般.value,
      敵名_ボス: 敵名_ボス.value,
      難易度_一般: 難易度_一般.value,
      難易度_ボス: 難易度_ボス.value,
      敵ステータス_一般: 敵ステータス_一般.value,
      敵ステータス_ボス: 敵ステータス_ボス.value,
      敵タブ: 敵タブ.value,
      ボス重要度: ボス重要度.value,
      スキルレベル: スキルレベル.value
    };
    
    localStorage.setItem('lataleCalcData', JSON.stringify(data));
    return true;
  } catch (error) {
    console.error('[saveToStorage] Failed to save settings:', error);
  }
  return false;
};
 
/**
 * ダメージ計算エンジン
 * DRY原則: 計算は1回のみ、動的にキーの存在をチェック
 * 初期化により型を保証、nullチェック不要
 * 
 * 命名規約:
 * - 表示値: ステータス画面に表示される値（補正前値 × 乗算値）
 * - 補正前値: 乗算補正を適用する前のベース値
 * - 乗算値: ％補正の値（100 = 100%増加）
 */

const getStatWithPrefix = (key, stats) => stats[getActualKey(key)];

const isPhysical = () => inputs.value.攻撃タイプ === '物理';

const mulKey = (stat) => {
  if(stat.startsWith('攻撃')) return '攻撃_乗算'
  return stat.replace(/^(物理|魔法)_/, '') + '_乗算';
};

function calculateBaseDamage(stats, enemyStats, enemyType, skillData) {
  
  let 攻撃力補正 = 1;
  let 属性攻撃補正 = 1;
  let 全ダメージ補正 = 1;
  let 効率 = 1;
  
  const 防御倍率 = 1 / Math.exp(enemyStats.防御 / 3761.35);
  const 貫通率 = getStatWithPrefix('貫通', stats) / 100;
  
  if (skillData.タイプ === '召喚') {
    攻撃力補正 = 1;
    属性攻撃補正 = 1;
    // 召喚補正のレベル依存計算
    const base = Number(skillData.召喚補正);
    const perLevel = Number(skillData.召喚補正上昇値);
    const level = Number(skillData.レベル);
    const totalBonus = base + (level - 1) * perLevel;
    全ダメージ補正 = totalBonus / 100;
  } else {
    効率 += stats.効率/ 100;
  }
    
  let 筋魔, 攻撃or属性, 最大, 最小, 追加ダメ;
  
  if (isPhysical()) {
    筋魔 = stats.筋力;
    攻撃or属性 = ((stats.攻撃最大) + (stats.攻撃最小)) * 攻撃力補正;
    最大 = getStatWithPrefix('最大', stats);
    最小 = getStatWithPrefix('最小', stats);
    追加ダメ = getStatWithPrefix('追加ダメ', stats);
  } else {
    筋魔 = stats.魔力;
    攻撃or属性 = (stats.属性) * 2 * 属性攻撃補正;
    最大 = getStatWithPrefix('最大', stats) + (stats.属性最大);
    最小 = getStatWithPrefix('最小', stats) + (stats.属性最小);
    追加ダメ = getStatWithPrefix('追加ダメ', stats);
  }
  
  最大 = Number(最大) + Number(stats.基礎最大);
  最小 = Number(最小) + Number(stats.基礎最小);
  
  追加ダメ += stats[enemyType + '追加ダメ']
  追加ダメ -= enemyStats.ダメ減;
  const 支配 = stats[enemyType + '支配']

  const 基本ダメージ1 = 攻撃or属性 * skillData.倍率 / 100;
  const 基本ダメージ2 = skillData.追加ダメ + 筋魔 * 効率;
  最小 = Math.min(最大 + 10, 最小);
    
  const result = (
    (基本ダメージ1 + 基本ダメージ2) * (1 - (1 - 防御倍率) * (1 - 貫通率))
      + 追加ダメ
  )
    * (1 + 支配 / 100)
    * (最大 + 最小) / 200 * 全ダメージ補正
    * (1 - enemyStats.ダメ減_乗算 / 100);
  
  return result;
}

function calculateCriRate(stats, enemyStats) {
  const クリ率 = getStatWithPrefix('クリ率', stats);
  const 幸運 = stats.幸運;
  return Math.min(100, クリ率 + 15 * 幸運 / enemyStats.幸運);
}

function calculateCriDamage(baseDamage, stats, enemyStats) {
  const クリダメ = getStatWithPrefix('クリダメ', stats);
  const クリダメ補正 = (100 + クリダメ) * (1 - enemyStats.クリ減 / 1000) / 100;
  return baseDamage * クリダメ補正;
}

function calculateDamage(baseDamage, criRate, criDamage) {
  const cr = criRate / 100;
  const nonCriPart = baseDamage * (1 - cr);
  const criPart = criDamage * cr;
  return nonCriPart + criPart;
}

function calculateDPS(damage) {
  
  const motionTimeInSeconds = inputs.value.モーション時間 / 10;
  const hitCount = inputs.value.ヒット数;
  const totalDamage = damage * hitCount;
  
  return totalDamage / motionTimeInSeconds;
}


const calculateDamages = (stats, enemyStats, enemyType, skillData) => {
  const baseDamage = calculateBaseDamage(stats, enemyStats, enemyType, skillData);
  const criRate = calculateCriRate(stats, enemyStats);
  const criDamage = calculateCriDamage(baseDamage, stats, enemyStats);
  const damage = calculateDamage(baseDamage, criRate, criDamage);
  
  return {
    baseDamage,
    criRate,
    criDamage,
    damage
  };
}

// 単一スキルのダメージ計算
function calculateSkillDamage(skillData, stats, enemyStats, enemyType) {

  const damages = calculateDamages(stats, enemyStats, enemyType, skillData);
  const skillDamage = damages.damage * skillData.HIT数;
  
  return {
    ...damages,
    skillDamage,
    hit数: skillData.HIT数,
    weight: skillData.ウェイト
  };
}

// 複数スキルの加重平均計算（statsを引数で受け取る版）
function calculateWeightedSkillDamageWithStats(stats, enemyStats, enemyType) {
  // 有効なスキルすべてが対象（スキル名の有無に関わらず）
  const 有効スキル = スキルリスト.value.filter(s => s.有効);
  
  // 各スキルのダメージを計算
  const skillResults = 有効スキル.map(skill => 
    calculateSkillDamage(skill, stats, enemyStats, enemyType)
  );
  
  // ウェイトの合計を計算
  const totalWeight = skillResults.reduce((sum, r) => sum + r.weight, 0);
  
  // 加重平均を計算
  const weightedResult = {
    baseDamage: 0,
    criRate: 0,
    criDamage: 0,
    damage: 0,
    skillDamage: 0
  };
  
  skillResults.forEach(result => {
    const weightRatio = result.weight / totalWeight;
    weightedResult.baseDamage += result.baseDamage * weightRatio;
    weightedResult.criRate += result.criRate * weightRatio;
    weightedResult.criDamage += result.criDamage * weightRatio;
    weightedResult.damage += result.damage * weightRatio;
    weightedResult.skillDamage += result.skillDamage * weightRatio;
  });
  
  return weightedResult;
}

// 複数スキルの加重平均計算（通常版）
function calculateWeightedSkillDamage(enemyStats, enemyType) {
  return calculateWeightedSkillDamageWithStats(inputs.value.stats, enemyStats, enemyType);
}

// 現在選択中のスキルだけのダメージ計算
function calculateCurrentSkillDamage(enemyStats, enemyType, currentSkill) {
  const stats = inputs.value.stats;
  
  // 単一スキルのダメージ計算（HIT数を考慮しない）
  const damages = calculateDamages(stats, enemyStats, enemyType, currentSkill);
  
  return damages;
}

function calculateResults(enemyStats, enemyType) {
  const stats = inputs.value.stats;
  
  // 複数スキルの加重平均ダメージを計算
  const baseResults = calculateWeightedSkillDamage(enemyStats, enemyType);
  // HIT数込みのダメージを使用
  const currentDamage = baseResults.skillDamage;

  // DPS計算（互換性のため残す）
  if (inputs.value.モーション時間 === null || inputs.value.ヒット数 === null) {
    baseResults.dps = currentDamage;
  } else {
    baseResults.dps = calculateDPS(currentDamage);
  }

  const damagePerStatPoint = key => {
    if (key === '経験値') {
      return Math.floor(currentDamage / 100 / (1 + stats[key] / 100));
    }

    const hpValue = inputs.value.HPダメージ換算 / 100;
    if (key === 'HP') {
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = (1 + HP_乗算 / 100) / HP;
      return Math.floor(currentDamage * HPincr * hpValue);
    }
    if (key === 'HP_乗算') {
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = (1 / (1 + HP_乗算 / 100)) / 100;
      return Math.floor(currentDamage * HPincr * hpValue);
    }
    if (key === '体力') {
      const 体力_乗算 = stats.体力_乗算;
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = 7 * (1 + 体力_乗算 / 100) * (1 + HP_乗算 / 100) / HP;
      return Math.floor(currentDamage * HPincr * hpValue);
    }
    if (key === '体力_乗算') {
      const 体力 = (stats.体力) / (1 + (stats.体力_乗算) / 100);
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = 体力 * 0.01 * 7 * (1 + HP_乗算 / 100) / HP;
      return Math.floor(currentDamage * HPincr * hpValue);
    }

    // 元データを変更しないよう stats をコピー
    const tmp = JSON.parse(JSON.stringify(inputs.value.stats));

    if (key === '攻撃_乗算') {
      const 乗算値 = tmp[key];
      ['攻撃最大', '攻撃最小'].forEach(attackKey => {
        const 補正前値 = tmp[attackKey] / (1 + 乗算値 / 100);
        tmp[attackKey] = 補正前値 * (1 + (乗算値 + 1) / 100);
      });
    } else if (key.endsWith('_乗算')) {
      const baseKey = key.replace('_乗算', '');
      const actualKey = getActualKey(baseKey);
      const 乗算値 = tmp[key];
      const 表示値 = tmp[actualKey];
      const 補正前値 = 表示値 / (1 + 乗算値 / 100);
      tmp[actualKey] = 補正前値 * (1 + (乗算値 + 1) / 100);
    } else if (key === '攻撃最大' || key === '攻撃最小') {
      tmp[key] += 1 + tmp.攻撃_乗算 / 100;
    } else if (key.endsWith('貫通')) {
      tmp[key] = 100 - (100 - tmp[key]) * 0.99;
    } else {
      const actualKey = getActualKey(key);
      const multiplierKey = mulKey(key);
      tmp[actualKey] ++;
      if (multiplierKey in tmp) {
        tmp[actualKey] += tmp[multiplierKey] / 100;
      }  
    }
    // ステータス変更後も加重平均で計算
    const newWeightedResult = calculateWeightedSkillDamageWithStats(tmp, enemyStats, enemyType);
    return Math.floor(newWeightedResult.skillDamage - currentDamage);
  };

  const damagePerStat = {};
  Object.keys(stats).forEach(key => {
    damagePerStat[key] = damagePerStatPoint(key);
  });

  return {
    baseDamage: baseResults.baseDamage,
    criRate: baseResults.criRate,
    criDamage: baseResults.criDamage,
    damage: baseResults.skillDamage,  // HIT数込みのダメージを返す
    dps: baseResults.dps,
    damagePerStat: damagePerStat
  };
}

/**
 * 基本値計算（％補正前の値）
 * @param {string} key - ステータスキー（プレフィックスなし）
 * @param {object} stats - ステータスオブジェクト
 */
function base(key, stats = inputs.value.stats) {
  
  if (key === '攻撃最大' || key === '攻撃最小') {
    const 乗算値 = stats.攻撃_乗算;
    return (stats[key]) / (1 + 乗算値 / 100);
  }
  
  const actualKey = getActualKey(key);
  const 表示値 = stats[actualKey];
  const 乗算キー = key + '_乗算';
  
  if (stats[乗算キー] !== undefined) {
    const 乗算値 = stats[乗算キー];
    return 表示値 / (1 + 乗算値 / 100);
  }
  return 表示値;
}

const getActualKey = (key) => {
  const prefixedKey = `${inputs.value.攻撃タイプ}_${key}`;
  return prefixedKey in inputs.value.stats ? prefixedKey : key;
}
 
/**
 * データローダー
 * 静的JSファイルから各種マスターデータを読み込み
 * 選択連動処理を管理
 */

// スキルデータ読み込み（静的データから）
function loadSkills() {
  try {
    // SKILLS_DATA と JOB_LIST は既にグローバルスコープに定義済み
    スキルマスター.value = SKILLS_DATA;
    職業リスト.value = JOB_LIST;
    
    return true;
  } catch (error) {
    console.error('Failed to load skills:', error);
    return false;
  }
}

// 敵データ読み込み
function loadEnemies() {
  try {
    // ENEMIES_DATA と DUNGEON_LIST は既にグローバルスコープに定義済み
    // 新しいデータ構造：一般とボスを最外側に分離
    敵マスター_一般.value = ENEMIES_DATA["一般"] || {};
    敵マスター_ボス.value = ENEMIES_DATA["ボス"] || {};
    ダンジョンリスト_一般.value = DUNGEON_LIST["一般"] || [];
    ダンジョンリスト_ボス.value = DUNGEON_LIST["ボス"] || [];
    
    return true;
  } catch (error) {
    console.error('Failed to load enemies:', error);
    return false;
  }
}

// 超越スキルデータ読み込み
function loadTranscendSkills() {
    try {
        // TRANSCEND_SKILLS_DATAは既にグローバルスコープに定義済み
        // 初期化データを生成して永続保持
        超越1初期化データ = initializeRankingData(TRANSCEND_SKILLS_DATA.filter(skill => skill.position <= 3));
        超越2_1初期化データ = initializeRankingData(TRANSCEND_SKILLS_DATA.filter(skill => skill.position === 4));
        超越2_2初期化データ = initializeRankingData(TRANSCEND_SKILLS_DATA.filter(skill => skill.position === 5));
        超越2_3初期化データ = initializeRankingData(TRANSCEND_SKILLS_DATA.filter(skill => skill.position === 6));
        
        // マスターデータは保持しない
        return true;
    } catch (error) {
        console.error('Failed to load transcend skills:', error);
        return false;
    }
}

// ギルドスキルデータ読み込み
function loadGuildSkills() {
    try {
        // GUILD_SKILLS_DATAは既にグローバルスコープに定義済み
        // 初期化データを生成して永続保持
        ギルドスキル初期化データ = initializeRankingData(GUILD_SKILLS_DATA);
        
        // マスターデータは保持しない
        return true;
    } catch (error) {
        console.error('Failed to load guild skills:', error);
        return false;
    }
}

// ペットパッシブデータ読み込み
function loadPetPassives() {
    try {
        // PET_PASSIVES_DATAは既にグローバルスコープに定義済み
        // 初期化データを生成して永続保持
        ペットパッシブ初期化データ = initializeRankingData(PET_PASSIVES_DATA);
        
        // マスターデータは保持しない
        return true;
    } catch (error) {
        console.error('Failed to load pet passives:', error);
        return false;
    }
}

// 全データ一括読み込み（同期処理に変更）
function loadAllData() {
  const results = [
    loadSkills(),
    loadEnemies(),
    loadTranscendSkills(),
    loadGuildSkills(),
    loadPetPassives()
  ];
  
  const success = results.every(r => r === true);
  
  if (!success) {
    console.error('Some data failed to load');
  }
  
  return success;
}

// 選択中のスキルデータ取得
function getSelectedSkillData() {
  if (!スキル名.value) return null;
  
  return スキルマスター.value.find(skill => 
    skill.スキル名 === スキル名.value && skill.職業 === 職業.value
  ) || null;
}

// 選択中の敵データ取得（enemyTypeを指定）
function getSelectedEnemyData(enemyType) {
  const ダンジョン = enemyType === '一般' ? ダンジョン_一般.value : ダンジョン_ボス.value;
  const 敵名 = enemyType === '一般' ? 敵名_一般.value : 敵名_ボス.value;
  const 難易度 = enemyType === '一般' ? 難易度_一般.value : 難易度_ボス.value;
  
  if (!ダンジョン || !敵名 || !難易度) {
    return null;
  }
  
  const dungeonData = get選択中ダンジョン敵データ(enemyType);
  if (!dungeonData || !dungeonData.enemies) return null;
  
  // 選択された敵を探す
  const selectedEnemy = dungeonData.enemies.find(e => e.name === 敵名);
  if (!selectedEnemy) return null;
  
  // 難易度別のステータスを取得
  const difficultyData = selectedEnemy.difficultyStats[難易度];
  if (!difficultyData) return null;
  
  // 基本ステータスと難易度別ステータスを統合して返す
  return {
    type: selectedEnemy.type,
    defense: selectedEnemy.baseStats.defense,
    luck: selectedEnemy.baseStats.luck,
    dmgReduce: difficultyData.dmgReduce,
    dmgReduceRatio: difficultyData.dmgReduceRatio,
    critReduce: difficultyData.critReduce
  };
}

// グローバル公開（window.不要、トップレベル関数はそのままアクセス可能）
 
// ランキング計算関数

/*　マスターjson
{
  name: 名前（必須）,
  position: 分類（オプション）,
  base_cost: （オプション）,
  cost_per_level: レベル毎コスト増分（オプション）,
  max_level: 最大レベル（オプション）,
  status_type1: ステータス名
  status_value1: 初期値1（必須）,
  status_value_slv1: レベル毎増分1（オプション）,
  status_type2: ステータス名2
  status_value2: 初期値2（オプション）,
  status_value_slv2: レベル毎増分2（オプション）,
}

初期化データ：
マスターロード時に生成　マスターデータは記憶しない
cost_per_level が存在すればレベル分レコードを複製
表示用のレベルとコストを固定して damage 以外の値を fix
{
  name: 名前（必須）,
  category: 分類（ギルド　ペット）,
  effect: ステータス（必須）,
  level: LV（cost_per_level ? level : max_level）,
  cost: P（base_cost + cost_per_level * (level - 1)）,
  status_type1: ステータス名1
  status_value1: 値1（必須）,
  status_type2: ステータス名2
  status_value2: 値2,
  damage: ダメ/P（必須　ここだけ更新される）
}
calcurateRanking では status_xxx からダメージ増加値を計算し cost で割った値を damage にセットしてソートするだけ

ヘッダ自動生成
[
name if exist: スキル名
category if exist: 分類
effect required, ステータス
level if exist: LV
cost if exist: 消費P
damage requi: cost ? ダメージ/コスト : ダメージ
]
*/

// 表示用ラベルマッピング（等価なものは除外）
const statusDisplayLabels = {
  'HP_乗算': 'HP%',
  '筋力_乗算': '筋力%',
  '魔力_乗算': '魔力%',
  '体力_乗算': '体力%',
  '幸運_乗算': '幸運%',
  '筋力魔力': '筋魔',
  '筋力魔力_乗算': '筋魔%',
  '攻撃最大': '最大',
  '攻撃最小': '最小',
  '最大_乗算': '最終最大',
  '最小_乗算': '最終最小',
  'クリダメ_乗算': '最終クリダメ',
  '追加ダメ_乗算': '追加ダメ%',
  '一般追加ダメ_乗算': '一般追加ダメ%',
  'ボス追加ダメ_乗算': 'ボス追加ダメ%',
  '攻撃_乗算': '攻撃%',
  '属性_乗算': '属性%',
  '武器属性_乗算': '武器属性%'
};

// スキル名の省略形変換マップ
const skillNameAbbreviations = {
  'クリティカルダメージ': 'クリダメ',
  'ダメージ減少': 'ダメ減',
  '一般モンスター追加ダメージ': '一般追加ダメ',
  'ボスモンスター追加ダメージ': 'ボス追加ダメ',
  'バックアタックダメージ': 'BA',
  '一般モンスター支配力': '一般支配',
  'ボスモンスター支配力': 'ボス支配',
  'クールタイム減少': 'CT減少',
  '筋力、魔法力': '筋魔',
  '物理/魔法追加ダメージ': '追加ダメ',
  '全ステータス': '全ステ',
  '武器属性力': '属性',
  '最大HP': 'HP',
  '最小ダメージ': '最小',
  '最大ダメージ': '最大',
  '筋力/魔力効率': '効率',
  'スキルターゲット数': 'タゲ数',
  '移動速度': '移動'
};

// スキル名を短縮形に変換
function shortenSkillName(name) {
  let shortened = name;
  for (const [full, short] of Object.entries(skillNameAbbreviations)) {
    shortened = shortened.replace(full, short);
  }
  // その他の簡略化
  shortened = shortened.replace(/\s*\(\+\)\s*/g, '');
  shortened = shortened.replace(/\s*\(%\)\s*/g, '%');
  shortened = shortened.replace(/\s*-\s*/g, '-');
  shortened = shortened.replace(/\\n/g, '/');
  shortened = shortened.replace('Ⅰ', '1');
  shortened = shortened.replace('Ⅱ', '2');
  return shortened;
}

// ダメージ換算（statusTypeは文字列）
function calculateDamageIncrease(statusType, value) {
  statusType = getActualKey(statusType);
  const damagePerStat = results.value.damagePerStat;
  
  // マッピングがあるものはそのまま使用
  if (statusType in damagePerStat) {
    return damagePerStat[statusType] * value;
  }
  
  // 特殊ケースの処理
  
  // 全ステータス（短縮形キーも処理）
  if (statusType === '全ステ' || statusType === '全ステータス') {
    return value * (damagePerStat['筋力'] + damagePerStat['体力'] + damagePerStat['幸運'] + damagePerStat['魔力']);
  }
  if (statusType === '全ステ%' || statusType === '全ステータス_乗算') {
    return value * (damagePerStat['筋力_乗算'] + damagePerStat['体力_乗算'] + damagePerStat['幸運_乗算'] + damagePerStat['魔力_乗算']);
  }
  
  // 筋力魔力（より高い方を採用）
  if (statusType === '筋力魔力') {
    return value * Math.max(damagePerStat['筋力'], damagePerStat['魔力']);
  }
  if (statusType === '筋力魔力_乗算') {
    return value * Math.max(damagePerStat['筋力_乗算'], damagePerStat['魔力_乗算']);
  }
  
  // 武器属性力の特殊処理
  if (statusType === '武器属性') {
    // 武器属性力(+) = 攻撃最大 + 攻撃最小 + 属性
    return value * (damagePerStat['攻撃最大'] + damagePerStat['攻撃最小'] + damagePerStat['属性']);
  }
  if (statusType === '武器属性_乗算') {
    // 武器属性力(%) = 攻撃_乗算 + 属性_乗算
    return value * (damagePerStat['攻撃_乗算'] + damagePerStat['属性_乗算']);
  }
  
  // 効率系
  if (statusType === '筋力効率' || statusType === '魔力効率') {
    return damagePerStat['効率'] * value;
  }
  
  // 最大最小（両方上げる）
  if (statusType === '最大最小') {
    const maxKey = getActualKey('最大');
    const minKey = getActualKey('最小');
    return value * (damagePerStat[maxKey] + damagePerStat[minKey]);
  }
  
  // その他マッピングがないもの
  return 0;
}

// 入力値のハッシュを生成（変更検出用）
function generateInputHash(stats) {
  const keys = ['str', 'vit', 'int', 'magic', 'agi', 'attrFire', 'attrWater', 'attrLight', 'attrWind'];
  return keys.map(k => stats[k]).join(',');
}

// 初期化データ生成（共通）
function initializeRankingData(skills) {
  const initialData = [];
  
  for (const skill of skills) {
    // 固定コストなら1回、可変コストならmax_level回
    const maxIterations = (skill.cost_per_level && skill.cost_per_level > 0) ? skill.max_level : 1;
    
    for (let level = 1; level <= maxIterations; level++) {
      const effects = [];
      
      // 値は固定（レベルによる変化なし）
      const value1 = skill.status_value1 || 0;
      const value2 = skill.status_value2 || 0;
      
      // エフェクト文字列を生成
      processStatusEffects(skill, value1, value2, effects);

      const dataItem = {
        id: skill.id,
        name: skill.name,
        effect: effects.join(skill.position === 5 ? '<br>' : ', '),
        // ステータス情報を保持（ダメージ計算用）
        status_type1: skill.status_type1,
        status_value1: value1,
        status_type2: skill.status_type2,
        status_value2: value2,
        // 初期値
        damage: 0
      };
      
      if ('category' in skill) dataItem.category = skill.category;
      if ('position' in skill) dataItem.position = skill.position;
            
      // レベルとコスト
      if ('base_cost' in skill) {
        if('max_level' in skill) {
          dataItem.cost = skill.base_cost + (level - 1) * (skill.cost_per_level || 0);
          dataItem.level = skill.cost_per_level > 0 ? level : skill.max_level;
        }
        else {
          dataItem.cost = skill.base_cost;
        }
      }
      
      initialData.push(dataItem);
    }
  }
  
  return initialData;
}

// ダメージ計算と更新（共通）
function calculateRankingDamage(data) {
  // 元ダメージ（一般とボス）を取得
  const baseDamageGeneral = results.value.ダメージ_一般 || 1;
  const baseDamageBoss = results.value.ダメージ_ボス || 1;
  const bossImportance = ボス重要度.value / 100;
  const generalImportance = 1 - bossImportance;
  
  // 平均ダメージ（増加率を実際のダメージ値に変換するため）
  const averageDamage = (baseDamageGeneral + baseDamageBoss) / 2;
  
  // 各アイテムのダメージを計算
  for (const item of data) {
    // 加重平均済みのdamagePerStatを使って直接計算
    let totalDamageIncrease = 0;
    if (item.status_value1) {
      totalDamageIncrease += calculateDamageIncrease(item.status_type1, item.status_value1);
    }
    if (item.status_type2 && item.status_value2) {
      totalDamageIncrease += calculateDamageIncrease(item.status_type2, item.status_value2);
    }
    
    // ここでtotalDamageIncreaseは既に加重平均済みのダメージ増加値
    let actualDamageIncrease = totalDamageIncrease;
    
    // 換算方法に応じて値を変換
    if (換算方法.value === 'クリダメ換算') {
      const criDamageKey = inputs.value.攻撃タイプ === '物理' ? '物理_クリダメ' : '魔法_クリダメ';
      const criDamageValue = results.value.damagePerStat[criDamageKey];
      if (criDamageValue) {
        actualDamageIncrease = actualDamageIncrease / criDamageValue;
      }
    } else if (換算方法.value === '筋魔換算') {
      const strIntKey = inputs.value.攻撃タイプ === '物理' ? '筋力' : '魔力';
      const strIntValue = results.value.damagePerStat[strIntKey];
      if (strIntValue) {
        actualDamageIncrease = actualDamageIncrease / strIntValue;
      }
    }
    
    // コストがある場合はコストで割る（ダメージ/P）
    if ('cost' in item && item.cost > 0) {
      item.damage = actualDamageIncrease / item.cost;
    } else {
      item.damage = actualDamageIncrease;
    }
  }
  
  // ソート
  return data.sort((a, b) => b.damage - a.damage);
}

// ヘッダー自動生成
function generateHeaders(data) {
  const headers = ['順位'];
  const sample = data[0];
  
  if (!sample) return headers;
  
  if ('name' in sample) headers.push('名前');
  if ('category' in sample) headers.push('分類');
  if ('effect' in sample) headers.push('ステータス');
  if ('level' in sample) headers.push('Lv');
  if ('cost' in sample) {
    headers.push('P');
    // 換算方法に応じてヘッダーを変更
    if (換算方法.value === '増加ダメ') {
      headers.push('ダメージ/P');
    } else if (換算方法.value === 'クリダメ換算') {
      headers.push('クリダメ/P');
    } else if (換算方法.value === '筋魔換算') {
      const key = inputs.value.攻撃タイプ === '物理' ? '筋力' : '魔力';
      headers.push(`${key}/P`);
    } else {
      headers.push('ダメージ/P');
    }
  }
  else {
    // 換算方法に応じてヘッダーを変更
    if (換算方法.value === '増加ダメ') {
      headers.push('ダメージ');
    } else if (換算方法.value === 'クリダメ換算') {
      headers.push('クリダメ換算');
    } else if (換算方法.value === '筋魔換算') {
      const key = inputs.value.攻撃タイプ === '物理' ? '筋力換算' : '魔力換算';
      headers.push(key);
    } else {
      headers.push('ダメージ');
    }
  }
  
  return headers;
}

// ステータスエフェクト処理（表示用テキスト生成のみ）
function processStatusEffects(skill, value1, value2, effects) {
  // 筋力効率と魔力効率が同じ値の場合
  if ((skill.status_type1 === '筋力効率' && skill.status_type2 === '魔力効率') || 
      (skill.status_type1 === '魔力効率' && skill.status_type2 === '筋力効率')) {
    if (value1 !== value2) {
      throw new Error('筋力魔力効率が異なる');
    }
    effects.push(`効率+${value1}`);
  }
  // 筋力%と魔力%が同じ値の場合
  else if ((skill.status_type1 === '筋力_乗算' && skill.status_type2 === '魔力_乗算') || 
      (skill.status_type1 === '魔力_乗算' && skill.status_type2 === '筋力_乗算')) {
    if (value1 !== value2) {
      throw new Error('筋力魔力%が異なる');
    }
    effects.push(`筋魔+${value1}%`);
  }
  // 筋力と魔力が同じ値の場合
  else if ((skill.status_type1 === '筋力' && skill.status_type2 === '魔力') || 
           (skill.status_type1 === '魔力' && skill.status_type2 === '筋力')) {
    if (value1 !== value2) {
      throw new Error('筋力魔力が異なる');
    }
    effects.push(`筋魔+${value1}`);
  }
  // その他の場合
  else {
    if (value1 !== 0) {
      effects.push(buildEffectString(skill.status_type1, value1));
    }
    
    if (skill.status_type2 && value2 !== 0) {
      effects.push(buildEffectString(skill.status_type2, value2));
    }
  }
}

// ランキング計算関数のファクトリー（共通処理）
function createRankingCalculator(initialData) {
  return () => {
    const rankedData = calculateRankingDamage(initialData);
    return {
      headers: generateHeaders(rankedData),
      data: rankedData
    };
  };
}

// 各ランキング計算関数を生成
const calculateTranscend1Rankings = () => createRankingCalculator(超越1初期化データ)();
const calculateTranscend2_1Rankings = () => createRankingCalculator(超越2_1初期化データ)();
const calculateTranscend2_2Rankings = () => createRankingCalculator(超越2_2初期化データ)();
const calculateTranscend2_3Rankings = () => createRankingCalculator(超越2_3初期化データ)();

// 効果文字列生成ヘルパー
function buildEffectString(statusType, value) {
  // 表示用ラベルを取得（マッピングがなければそのまま）
  const statName = statusDisplayLabels[statusType] || statusType;
  
  // パーセント系の処理
  const isPercent = statName.includes('%');
  const displayName = isPercent ? statName.replace('%', '') : statName;
  
  // 符号処理: 正の数には+を付け、負の数はそのまま（既に-が付いている）
  const sign = value > 0 ? '+' : '';
  return `${displayName}${sign}${value}${isPercent ? '%' : ''}`;
}

/* 
[{
cost_per_level, 
max_level, 
status_type1,  
status_value1,
status_type2,  
status_value2
}]
*/
// 従来の計算関数（削除予定）
const calculateRankings = skills => {
  const rankings = [];
  // この関数は使われていないので、calculateRankingDamageを使うように統一
  return rankings;
}

const calculateGuildSkillRankings = () => createRankingCalculator(ギルドスキル初期化データ)();
const calculatePetPassiveRankings = () => createRankingCalculator(ペットパッシブ初期化データ)();

/**
 * グラフ探索によるルート生成（覚醒スキル用）
 * @param {Array} nodes - 覚醒ノードの配列
 * @param {number} maxPoints - 使用可能ポイント数
 * @returns {Array} 可能なルートの配列
 */
function generatePossibleRoutes(nodes, maxPoints) {
  if (!maxPoints || maxPoints <= 0) return [];
  
  // ノードIDをキーとしたマップを作成
  const nodeMap = {};
  nodes.forEach(node => {
    nodeMap[node.slot] = node;
  });
  
  // 動的計画法で最適ルートを探索
  const routes = [];
  
  // 深さ優先探索で全ルートを探索（計算量を抑えるため上位のみ保持）
  function dfs(currentNodes, remainingPoints, visitedSet) {
    if (remainingPoints <= 0 || routes.length >= 1000) {
      // ルートを保存（最大1000パターンまで）
      routes.push([...currentNodes]);
      return;
    }
    
    // 次に選択可能なノードを探す
    for (const node of nodes) {
      if (visitedSet.has(node.slot)) continue;
      
      // 前提条件チェック（OR条件）
      if (node.requires && node.requires.length > 0) {
        const hasPrereq = node.requires.some(reqId => visitedSet.has(reqId));
        if (!hasPrereq) continue;
      }
      
      // 排他条件チェック
      if (node.limits && node.limits.length > 0) {
        const hasLimit = node.limits.some(limitId => visitedSet.has(limitId));
        if (hasLimit) continue;
      }
      
      // このノードを選択
      visitedSet.add(node.slot);
      currentNodes.push(node);
      
      // 再帰的に探索
      dfs(currentNodes, remainingPoints - 1, visitedSet);
      
      // バックトラック
      currentNodes.pop();
      visitedSet.delete(node.slot);
    }
  }
  
  // 前提条件のないノードから開始
  const startNodes = nodes.filter(node => !node.requires || node.requires.length === 0);
  
  for (const startNode of startNodes) {
    const visited = new Set([startNode.slot]);
    dfs([startNode], maxPoints - 1, visited);
  }
  
  return routes;
}

/**
 * ルートのダメージ換算値を計算（覚醒用）
 * @param {Array} route - ノードの配列
 * @returns {number} ダメージ換算値
 */
function calculateRouteDamageValue(route) {
  if (!route || route.length === 0) return 0;
  
  let totalValue = 0;
  
  route.forEach(node => {
    if (!node.stats) return;
    
    node.stats.forEach(stat => {
      // calculateDamageIncreaseは既にgetActualKeyで動的変換しているので直接stat.nameを渡す
      const damageIncrement = calculateDamageIncrease(stat.name, stat.value);
      totalValue += damageIncrement;
    });
  });
  
  return totalValue;
}


/**
 * 覚醒1の最適ルートランキングを計算
 */
const calculateAwaken1Rankings = () => {
  if (typeof awakenData === 'undefined' || !awakenData || !awakenData.awaken1) {
    return { headers: ['順位', '名前', 'ステータス', 'ダメ換算'], data: [], totalDamage: 0 };
  }
  
  const points = 覚醒1ポイント.value;
  if (!points || points <= 0) {
    return { headers: ['順位', '名前', 'ステータス', 'ダメ換算'], data: [], totalDamage: 0 };
  }
  
  // 可能なルートを生成
  const routes = generatePossibleRoutes(awakenData.awaken1.nodes, points);
  
  if (routes.length === 0) {
    return { headers: ['順位', '名前', 'ステータス', 'ダメ換算'], data: [], totalDamage: 0 };
  }
  
  // 各ルートのダメージ換算値を計算してソート
  const rankedRoutes = routes.map(route => {
    const damage = calculateRouteDamageValue(route);
    return {
      damage,
      nodes: route
    };
  }).sort((a, b) => b.damage - a.damage);
  
  // 最適ルート（1位）のスキルを依存関係順で表示
  const bestRoute = rankedRoutes[0];
  if (!bestRoute) {
    return { headers: ['順位', '名前', 'ステータス', 'ダメ換算'], data: [], totalDamage: 0 };
  }
  
  // 合計ダメージを保持
  let totalDamage = 0;
  
  // 各ノードを個別の行として展開
  const data = bestRoute.nodes.map((node, index) => {
    // このノードのステータス効果を集計
    const stats = [];
    let nodeDamage = 0;
    
    node.stats.forEach(stat => {
      stats.push(`${stat.name}+${stat.value}`);
      const damageIncrement = calculateDamageIncrease(stat.name, stat.value);
      nodeDamage += damageIncrement;
    });
    
    totalDamage += nodeDamage;
    
    return {
      id: `awaken1_${index}`,
      name: node.name,
      stats: stats.join(' '),
      damage: nodeDamage
    };
  });
  
  return {
    headers: ['順位', '名前', 'ステータス', 'ダメ換算'],
    data: data,
    totalDamage: totalDamage
  };
};

/**
 * 覚醒2の最適ルートランキングを計算
 */
const calculateAwaken2Rankings = () => {
  if (typeof awakenData === 'undefined' || !awakenData || !awakenData.awaken2) {
    return { headers: ['順位', '名前', 'ステータス', 'ダメ換算'], data: [], totalDamage: 0 };
  }
  
  const points = 覚醒2ポイント.value;
  if (!points || points <= 0) {
    return { headers: ['順位', '名前', 'ステータス', 'ダメ換算'], data: [], totalDamage: 0 };
  }
  
  // 可能なルートを生成
  const routes = generatePossibleRoutes(awakenData.awaken2.nodes, points);
  
  if (routes.length === 0) {
    return { headers: ['順位', '名前', 'ステータス', 'ダメ換算'], data: [], totalDamage: 0 };
  }
  
  // 各ルートのダメージ換算値を計算してソート
  const rankedRoutes = routes.map(route => {
    const damage = calculateRouteDamageValue(route);
    return {
      damage,
      nodes: route
    };
  }).sort((a, b) => b.damage - a.damage);
  
  // 最適ルート（1位）のスキルを依存関係順で表示
  const bestRoute = rankedRoutes[0];
  if (!bestRoute) {
    return { headers: ['順位', '名前', 'ステータス', 'ダメ換算'], data: [], totalDamage: 0 };
  }
  
  // 合計ダメージを保持
  let totalDamage = 0;
  
  // 各ノードを個別の行として展開
  const data = bestRoute.nodes.map((node, index) => {
    // このノードのステータス効果を集計
    const stats = [];
    let nodeDamage = 0;
    
    node.stats.forEach(stat => {
      stats.push(`${stat.name}+${stat.value}`);
      const damageIncrement = calculateDamageIncrease(stat.name, stat.value);
      nodeDamage += damageIncrement;
    });
    
    totalDamage += nodeDamage;
    
    return {
      id: `awaken2_${index}`,
      name: node.name,
      stats: stats.join(' '),
      damage: nodeDamage
    };
  });
  
  return {
    headers: ['順位', '名前', 'ステータス', 'ダメ換算'],
    data: data,
    totalDamage: totalDamage
  };
};
 
// 覚醒スキルツリー Canvas実装

class AwakenSkillTree {
  constructor(canvasId, page) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.page = page; // 1 or 2 (覚醒1 or 覚醒2)
    
    // Canvas設定（背景画像サイズに合わせる）
    this.canvas.width = 1940;  // XMLのBG ATTR_BASE_OBJECT_SIZE_X
    this.canvas.height = 1060; // BG ATTR_BASE_OBJECT_SIZE_Y
    
    // 状態管理
    this.activeNodes = new Set();
    this.lockedNodes = new Set();
    this.hoveredNode = null;
    this.isLockMode = false;
    
    // データ
    this.nodes = [];
    this.nodeMap = {};
    this.edges = []; // 依存関係の線
    
    // 職業名→CLASS_IDマッピング（逆引き）
    this.classNameToId = {};
    if (typeof awakenData !== 'undefined' && awakenData.classMapping) {
      Object.entries(awakenData.classMapping).forEach(([id, name]) => {
        this.classNameToId[name] = parseInt(id);
      });
    }
    
    // 背景画像
    this.bgImage = null;
    this.bgImageLoaded = false;
    
    // イベントリスナー
    this.setupEventListeners();
    
    // 背景画像を読み込み
    this.loadBackgroundImage();
    
    // 初期化
    this.init();
  }
  
  loadBackgroundImage() {
    this.bgImage = new Image();
    const bgPath = this.page === 1 ? 'img/awaken1_bg.png' : 'img/awaken2_bg.png';
    this.bgImage.onload = () => {
      this.bgImageLoaded = true;
      this.draw();
    };
    this.bgImage.onerror = () => {
      console.log(`Background image not found: ${bgPath}`);
      this.bgImageLoaded = false;
    };
    this.bgImage.src = bgPath;
  }
  
  init() {
    // awakenDataから座標も取得
    if (typeof awakenData !== 'undefined') {
      const pageData = this.page === 1 ? awakenData.awaken1 : awakenData.awaken2;
      const coordsData = pageData.coords;
      
      // ノードデータと座標を結合（x,yは中心座標、サイズは0.6倍）
      pageData.nodes.forEach(node => {
        const coords = coordsData[node.slot];
        if (coords) {
          // 中心座標を計算（XMLは左上座標）
          const centerX = coords.x + coords.width / 2;
          const centerY = coords.y + coords.height / 2;
          
          // サイズを0.6倍
          const width = coords.width * 0.6;
          const height = coords.height * 0.6;
          
          maxX = Math.max(maxX, centerX + width / 2);
          maxY = Math.max(maxY, centerY + height / 2);
          
          this.nodes.push({
            ...node,
            x: centerX,  // 中心座標
            y: centerY,  // 中心座標
            width: width,
            height: height
          });
          this.nodeMap[node.slot] = this.nodes[this.nodes.length - 1];
        }
      });
      
      // 依存関係の線を作成
      this.buildEdges();
      
      // ルートノード（前提条件のないノード）を自動有効化
      this.initializeRootNodes();
      
      // 初期描画
      this.draw();
    }
  }
  
  buildEdges() {
    // 依存関係から線を作成
    this.nodes.forEach(node => {
      if (node.requires && node.requires.length > 0) {
        node.requires.forEach(reqId => {
          const reqNode = this.nodeMap[reqId];
          if (reqNode) {
            this.edges.push({
              from: reqNode,
              to: node
            });
          }
        });
      }
    });
  }
  
  getCurrentClassId() {
    // 現在選択中の職業名からCLASS_IDを取得
    const currentSkill = get現在スキル();
    if (!currentSkill || !currentSkill.職業) return null;
    return this.classNameToId[currentSkill.職業] || null;
  }
  
  getNodeSkillInfo(node) {
    // ノードから職業に応じたスキル情報を取得
    // 共通スキルの場合: node.name, node.stats, node.descriptionが直接存在
    // 職業別スキルの場合: node.class_skills[classId]から取得
    
    if (node.skill_id !== undefined) {
      // 共通スキル
      return {
        name: node.name,
        stats: node.stats || [],
        description: node.description || ''
      };
    } else if (node.class_skills) {
      // 職業別スキル
      const classId = this.getCurrentClassId();
      const skillInfo = classId ? node.class_skills[classId] : null;
      
      if (skillInfo) {
        return {
          name: skillInfo.name,
          stats: skillInfo.stats || [],
          description: skillInfo.description || ''
        };
      }
    }
    
    // フォールバック
    return {
      name: `スロット${node.slot}`,
      stats: [],
      description: ''
    };
  }
  
  getNodeValue(node) {
    // ノードのダメージ価値をリアルタイム計算（職業refが変わると自動更新）
    let totalValue = 0;
    const skillInfo = this.getNodeSkillInfo(node);
    
    skillInfo.stats.forEach(stat => {
      const damageIncrement = calculateDamageIncrease(stat.name, stat.value);
      totalValue += damageIncrement;
    });
    
    return totalValue;
  }
  
  initializeRootNodes() {
    // 最初のノード（slot番号が最小）をルートノードとして自動有効化
    if (this.nodes.length > 0) {
      const rootNode = this.nodes.reduce((min, node) => 
        node.slot < min.slot ? node : min
      , this.nodes[0]);
      this.activeNodes.add(rootNode.slot);
    }
  }
  
  setupEventListeners() {
    // マウスクリック
    this.canvas.addEventListener('click', (e) => {
      const rect = this.canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (this.canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (this.canvas.height / rect.height);
      this.handleClick(x, y);
    });
    
    // マウス移動（ホバー）
    this.canvas.addEventListener('mousemove', (e) => {
      const rect = this.canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (this.canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (this.canvas.height / rect.height);
      this.handleHover(x, y, e.clientX, e.clientY);
    });
    
    // マウスアウト
    this.canvas.addEventListener('mouseout', () => {
      this.hoveredNode = null;
      this.draw();
    });
  }
  
  handleClick(x, y) {
    const clickedNode = this.getNodeAt(x, y);
    if (!clickedNode) return;
    
    if (this.activeNodes.has(clickedNode.slot)) {
      // すでにアクティブなノード
      if (this.isLockMode) {
        // ロックモード：ロック/アンロック
        if (this.lockedNodes.has(clickedNode.slot)) {
          this.lockedNodes.delete(clickedNode.slot);
        } else {
          this.lockedNodes.add(clickedNode.slot);
        }
      } else {
        // 非ロックモード：OFF + 依存ノードもOFF
        this.deactivateNode(clickedNode);
      }
    } else {
      // 非アクティブなノード：前提条件を満たしていればON
      this.activateNode(clickedNode);
    }
    
    this.updatePointDisplay();
    this.draw();
  }
  
  activateNode(node) {
    // 排他条件を確認（limitsのいずれかが有効化されていたらNG）
    if (node.limits && node.limits.length > 0) {
      const hasLimit = node.limits.some(limitId => this.activeNodes.has(limitId));
      if (hasLimit) {
        return;
      }
    }
    
    // 前提条件がない（ルートノード）場合は即座に有効化
    if (!node.requires || node.requires.length === 0) {
      this.activeNodes.add(node.slot);
      return;
    }
    
    // 既に前提条件を満たしている場合は即座に有効化
    const hasRequirement = node.requires.some(reqId => this.activeNodes.has(reqId));
    if (hasRequirement) {
      this.activeNodes.add(node.slot);
      return;
    }
    
    // 前提条件を満たしていない場合：最適経路を探索して自動有効化
    const path = this.findBestPath(node);
    if (path) {
      path.forEach(slot => this.activeNodes.add(slot));
    }
  }
  
  findBestPath(targetNode) {
    // 順方向BFS: 既存ノードからターゲットまでの最短距離を求める
    const distances = new Map();
    const queue = [];
    
    // 初期化：全アクティブノードを距離0でキューに追加
    this.activeNodes.forEach(slot => {
      distances.set(slot, 0);
      queue.push(slot);
    });
    
    let targetDistance = null;
    
    while (queue.length > 0) {
      const current = queue.shift();
      const currentDist = distances.get(current);
      
      if (current === targetNode.slot) {
        targetDistance = currentDist;
        break;
      }
      
      // 隣接ノードを探索（無向グラフ）
      this.nodes.forEach(node => {
        if (distances.has(node.slot)) return;
        
        const isAdjacent = 
          (node.requires && node.requires.includes(current)) ||
          (this.nodeMap[current].requires && this.nodeMap[current].requires.includes(node.slot));
        
        if (isAdjacent) {
          // 排他条件チェック
          if (node.limits && node.limits.some(limitId => this.activeNodes.has(limitId))) {
            return;
          }
          
          distances.set(node.slot, currentDist + 1);
          queue.push(node.slot);
        }
      });
    }
    
    if (targetDistance === null) {
      return null;
    }
    
    // 逆方向探索: ターゲットから距離分戻って既存ノードに到達する全パスを収集
    const findPaths = (slot, remainingDist) => {
      if (remainingDist === 0) {
        if (this.activeNodes.has(slot)) {
          return [[slot]];
        }
        return [];
      }
      
      const paths = [];
      this.nodes.forEach(node => {
        // 1つ手前の距離のノードのみ探索
        if (distances.get(node.slot) !== distances.get(slot) - 1) return;
        
        // 隣接チェック（無向グラフ）
        const isAdjacent = 
          (this.nodeMap[slot].requires && this.nodeMap[slot].requires.includes(node.slot)) ||
          (node.requires && node.requires.includes(slot));
        
        if (isAdjacent) {
          const subPaths = findPaths(node.slot, remainingDist - 1);
          subPaths.forEach(subPath => {
            paths.push([...subPath, slot]);
          });
        }
      });
      
      return paths;
    };
    
    const allPaths = findPaths(targetNode.slot, targetDistance);
    
    // 最高スコアのパスを選択
    let bestPath = null;
    let bestScore = -Infinity;
    
    allPaths.forEach(path => {
      const newNodes = path.filter(slot => !this.activeNodes.has(slot));
      const score = newNodes.reduce((sum, slot) => {
        const node = this.nodeMap[slot];
        return sum + (node ? this.getNodeValue(node) : 0);
      }, 0);
      
      if (score > bestScore) {
        bestScore = score;
        bestPath = path;
      }
    });
    
    return bestPath;
  }
  
  findAllPaths(startSlot, targetSlot, visited = new Set()) {
    // startSlotからtargetSlotへの全経路を探索（無向グラフ）
    if (startSlot === targetSlot) {
      return [[startSlot]];
    }
    
    visited.add(startSlot);
    const paths = [];
    
    // 隣接ノードを全て探索（無向グラフなので双方向）
    this.nodes.forEach(node => {
      if (visited.has(node.slot)) return;
      
      // startSlotとnodeが隣接しているか
      const isAdjacent = 
        (node.requires && node.requires.includes(startSlot)) ||
        (this.nodeMap[startSlot].requires && this.nodeMap[startSlot].requires.includes(node.slot));
      
      if (isAdjacent) {
        // 排他条件チェック
        if (node.limits && node.limits.some(limitId => this.activeNodes.has(limitId))) {
          return;
        }
        
        const subPaths = this.findAllPaths(node.slot, targetSlot, new Set(visited));
        subPaths.forEach(subPath => {
          paths.push([startSlot, ...subPath]);
        });
      }
    });
    
    return paths;
  }
  
  
  deactivateNode(node) {
    // スロット1（スタート）はOFF禁止
    if (node.slot === 1) {
      return;
    }
    
    // ロックされているノードはOFF不可
    if (this.lockedNodes.has(node.slot)) {
      return;
    }
    
    // このノードをOFF
    this.activeNodes.delete(node.slot);
    this.lockedNodes.delete(node.slot);
    
    // ルートから到達不可能になったノードを全てOFF
    this.removeUnreachableNodes();
  }
  
  removeUnreachableNodes() {
    // スロット1（スタート）から到達可能なノードを全てマーク（BFS）
    const reachable = new Set();
    const queue = [1]; // スロット1から開始
    reachable.add(1);
    
    while (queue.length > 0) {
      const current = queue.shift();
      
      // currentに隣接するアクティブノードを探索
      this.nodes.forEach(node => {
        if (!this.activeNodes.has(node.slot) || reachable.has(node.slot)) {
          return;
        }
        
        // currentとnodeが隣接しているか（無向グラフ）
        const isAdjacent = 
          (node.requires && node.requires.includes(current)) ||
          (this.nodeMap[current].requires && this.nodeMap[current].requires.includes(node.slot));
        
        if (isAdjacent) {
          reachable.add(node.slot);
          queue.push(node.slot);
        }
      });
    }
    
    // 到達不可能なアクティブノードを全てOFF
    const toRemove = [];
    this.activeNodes.forEach(slot => {
      if (!reachable.has(slot)) {
        toRemove.push(slot);
      }
    });
    
    toRemove.forEach(slot => {
      this.activeNodes.delete(slot);
      this.lockedNodes.delete(slot);
    });
  }
  
  handleHover(x, y, clientX, clientY) {
    const prevHovered = this.hoveredNode;
    this.hoveredNode = this.getNodeAt(x, y);
    
    if (prevHovered !== this.hoveredNode) {
      this.draw();
      
      // ツールチップ表示
      if (this.hoveredNode) {
        this.showTooltip(x, y, clientX, clientY, this.hoveredNode);
      } else {
        this.hideTooltip();
      }
    }
  }
  
  getNodeAt(x, y) {
    // クリック位置のノードを取得（形状に応じた判定）
    for (const node of this.nodes) {
      const centerX = node.x;  // node.xは既に中心座標
      const centerY = node.y;  // node.yは既に中心座標
      const radius = Math.min(node.width, node.height) / 2;
      
      let hit = false;
      const nodeType = node.type;
      
      if (nodeType === 0) {
        // タイプ0（円）：中心からの距離で判定
        const dx = x - centerX;
        const dy = y - centerY;
        hit = (dx * dx + dy * dy) <= (radius * radius);
      } else if (nodeType === 2) {
        // タイプ2（六角形）：矩形の近似判定
        const leftX = centerX - node.width / 2;
        const topY = centerY - node.height / 2;
        hit = (x >= leftX && x <= leftX + node.width &&
               y >= topY && y <= topY + node.height);
      } else {
        // タイプ1（四角）：矩形判定
        const leftX = centerX - node.width / 2;
        const topY = centerY - node.height / 2;
        hit = (x >= leftX && x <= leftX + node.width &&
               y >= topY && y <= topY + node.height);
      }
      
      if (hit) {
        return node;
      }
    }
    return null;
  }
  
  draw() {
    // クリア
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // 背景画像を描画（読み込み済みの場合のみ）
    if (this.bgImageLoaded && this.bgImage) {
      this.ctx.drawImage(this.bgImage, 0, 0, this.canvas.width, this.canvas.height);
    }
    
    // 依存関係の線を描画
    this.drawEdges();
    
    // ノードを描画
    this.drawNodes();
    
    // 合計スコア表示
    this.drawTotalScore();
  }
  
  drawEdges() {
    this.edges.forEach(edge => {
      const isActive = this.activeNodes.has(edge.from.slot) && 
                      this.activeNodes.has(edge.to.slot);
      
      const getCenterX = (node) => node.x;  // node.xは既に中心座標
      const getCenterY = (node) => node.y;  // node.yは既に中心座標
      
      this.ctx.beginPath();
      this.ctx.moveTo(getCenterX(edge.from), getCenterY(edge.from));
      this.ctx.lineTo(getCenterX(edge.to), getCenterY(edge.to));
      
      if (isActive) {
        // アクティブライン（黄色）
        this.ctx.strokeStyle = '#FFD700';
        this.ctx.lineWidth = 3;
      } else {
        // 非アクティブライン（黒）
        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.lineWidth = 1;
      }
      
      this.ctx.stroke();
    });
  }
  
  drawNodes() {
    this.nodes.forEach(node => {
      const isActive = this.activeNodes.has(node.slot);
      const isLocked = this.lockedNodes.has(node.slot);
      const isHovered = this.hoveredNode === node;
      
      // ノードの色を決定
      let fillColor, strokeColor;
      
      if (isActive) {
        if (isLocked) {
          fillColor = '#FF6B6B';
          strokeColor = '#FF0000';
        } else {
          fillColor = '#FFD700';
          strokeColor = '#FFA500';
        }
      } else {
        fillColor = 'rgba(0, 0, 0, 0.8)';
        strokeColor = 'rgba(0, 0, 0, 1.0)';
      }
      
      const centerX = node.x;  // node.xは既に中心座標
      const centerY = node.y;  // node.yは既に中心座標
      const radius = Math.min(node.width, node.height) / 2;
      
      this.ctx.fillStyle = fillColor;
      this.ctx.strokeStyle = strokeColor;
      this.ctx.lineWidth = isHovered ? 4 : (isActive ? 3 : 2);
      
      // typeに応じて形状を変更（タイプ0=円、タイプ1=四角、タイプ2=六角形）
      const nodeType = node.type;
      
      if (nodeType === 0) {
        // タイプ0：円
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
      } else if (nodeType === 2) {
        // タイプ2：六角形
        this.ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i - Math.PI / 2;
          const x = centerX + radius * Math.cos(angle);
          const y = centerY + radius * Math.sin(angle);
          if (i === 0) {
            this.ctx.moveTo(x, y);
          } else {
            this.ctx.lineTo(x, y);
          }
        }
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
      } else {
        // タイプ1またはデフォルト：四角
        const leftX = centerX - node.width / 2;
        const topY = centerY - node.height / 2;
        this.ctx.fillRect(leftX, topY, node.width, node.height);
        this.ctx.strokeRect(leftX, topY, node.width, node.height);
      }
    });
  }
  
  drawTotalScore() {
    // 合計スコア計算（職業refが変わると自動更新）
    let totalScore = 0;
    this.activeNodes.forEach(slot => {
      const node = this.nodeMap[slot];
      if (node) {
        totalScore += this.getNodeValue(node);
      }
    });
    
    // 表示
    this.ctx.font = 'bold 24px Arial';
    this.ctx.fillStyle = '#FFFFFF';
    this.ctx.strokeStyle = '#000000';
    this.ctx.lineWidth = 3;
    
    const text = `合計スコア: ${totalScore.toFixed(2)}`;
    const x = 20;
    const y = 40;
    
    this.ctx.strokeText(text, x, y);
    this.ctx.fillText(text, x, y);
    
    // 累積ポイント表示
    const usedPoints = this.activeNodes.size;
    const pointText = `累積ポイント: ${usedPoints}`;
    
    this.ctx.font = '18px Arial';
    this.ctx.strokeText(pointText, x, y + 30);
    this.ctx.fillText(pointText, x, y + 30);
  }
  
  lightenColor(color) {
    // 色を明るくする
    if (color.startsWith('rgba')) {
      return color.replace(/[\d.]+\)$/, '0.8)');
    }
    return color;
  }
  
  showTooltip(x, y, clientX, clientY, node) {
    const tooltip = document.getElementById('awaken-tooltip');
    if (!tooltip) return;
    
    const skillInfo = this.getNodeSkillInfo(node);
    
    let html = `<strong>${skillInfo.name}</strong><br>`;
    
    // エフェクト文字列を生成（rankings.jsと同じ形式）
    skillInfo.stats.forEach(stat => {
      const effectStr = this.buildEffectString(stat.name, stat.value);
      html += `${effectStr}<br>`;
    });
    
    const damage = this.getNodeValue(node);
    html += `<br><strong>ダメージ価値: ${damage.toFixed(2)}</strong>`;
    
    tooltip.innerHTML = html;
    tooltip.style.display = 'block';
    
    // ツールチップは親要素（Canvas親コンテナ）基準のabsolute配置
    // 親要素のrectを取得
    const parentRect = this.canvas.parentElement.getBoundingClientRect();
    
    // 親要素基準の座標に変換
    const relativeX = clientX - parentRect.left;
    const relativeY = clientY - parentRect.top;
    
    // ツールチップのサイズを取得
    const tooltipWidth = tooltip.offsetWidth || 200;
    const tooltipHeight = tooltip.offsetHeight || 80;
    
    // 画面端判定（オフセット10px）
    const offset = 10;
    let tooltipX = relativeX + offset;
    let tooltipY = relativeY - tooltipHeight - offset;
    
    // 右端判定：ツールチップが親要素右端を超える場合は左側に表示
    if (tooltipX + tooltipWidth > parentRect.width) {
      tooltipX = relativeX - tooltipWidth - offset;
    }
    
    // 上端判定：ツールチップが親要素上端を超える場合は下側に表示
    if (tooltipY < 0) {
      tooltipY = relativeY + offset;
    }
    
    tooltip.style.left = tooltipX + 'px';
    tooltip.style.top = tooltipY + 'px';
  }
  
  buildEffectString(statusType, value) {
    // 表示用ラベルマッピング（rankings.jsと同じ）
    const statusDisplayLabels = {
      'HP_乗算': 'HP%',
      '筋力_乗算': '筋力%',
      '魔力_乗算': '魔力%',
      '体力_乗算': '体力%',
      '幸運_乗算': '幸運%',
      '筋力魔力': '筋魔',
      '筋力魔力_乗算': '筋魔%',
      '攻撃最大': '最大',
      '攻撃最小': '最小',
      '最大_乗算': '最終最大',
      '最小_乗算': '最終最小',
      'クリダメ_乗算': '最終クリダメ',
      '追加ダメ_乗算': '追加ダメ%',
      '一般追加ダメ_乗算': '一般追加ダメ%',
      'ボス追加ダメ_乗算': 'ボス追加ダメ%',
      '攻撃_乗算': '攻撃%',
      '属性_乗算': '属性%',
      '武器属性_乗算': '武器属性%'
    };
    
    const statName = statusDisplayLabels[statusType] || statusType;
    
    const isPercent = statName.includes('%');
    const displayName = isPercent ? statName.replace('%', '') : statName;
    
    const sign = value > 0 ? '+' : '';
    return `${displayName}${sign}${value}${isPercent ? '%' : ''}`;
  }
  
  hideTooltip() {
    const tooltip = document.getElementById('awaken-tooltip');
    if (tooltip) {
      tooltip.style.display = 'none';
    }
  }
  
  updatePointDisplay() {
    // Canvas内部のactiveNodesをstore.jsのrefと同期
    if (this.page === 1) {
      覚醒1アクティブノード.value = this.activeNodes;
    } else {
      覚醒2アクティブノード.value = this.activeNodes;
    }
  }
  
  // オート最適化（追加ポイント分で最大効率）
  autoOptimize() {
    const maxPoints = this.page === 1 ? 覚醒1ポイント.value : 覚醒2ポイント.value;
    
    if (maxPoints <= 0) {
      return;
    }
    
    // 現在ONのノードは全て保持
    const newActiveNodes = new Set(this.activeNodes);
    
    // 残りポイント分だけループ
    let remainingPoints = maxPoints;
    while (remainingPoints > 0) {
      // 全ての未取得ノードに対して最短パスとその効率を計算
      let bestPath = null;
      let bestEfficiency = -Infinity;
      
      this.nodes.forEach(targetNode => {
        if (newActiveNodes.has(targetNode.slot)) return;
        
        // このノードへの最短パスを探索（BFS）
        const path = this.findShortestPath(targetNode, newActiveNodes);
        if (!path || path.length === 0) return;
        
        // パス上の新規ノードのみ抽出
        const newNodes = path.filter(slot => !newActiveNodes.has(slot));
        const cost = newNodes.length;
        
        // コストが残りポイントを超える場合はスキップ
        if (cost > remainingPoints) return;
        
        // パス全体の価値を計算
        const totalValue = newNodes.reduce((sum, slot) => {
          const node = this.nodeMap[slot];
          return sum + (node ? this.getNodeValue(node) : 0);
        }, 0);
        
        // 効率 = 価値 / コスト
        const efficiency = cost > 0 ? totalValue / cost : 0;
        
        if (efficiency > bestEfficiency) {
          bestEfficiency = efficiency;
          bestPath = newNodes;
        }
      });
      
      if (!bestPath || bestPath.length === 0) {
        break;
      }
      
      // 最高効率のパスを追加
      bestPath.forEach(slot => newActiveNodes.add(slot));
      remainingPoints -= bestPath.length;
    }
    
    // 更新
    this.activeNodes = newActiveNodes;
    this.updatePointDisplay();
    this.draw();
    
    // 追加ポイント入力欄を0にリセット
    if (this.page === 1) {
      覚醒1ポイント.value = 0;
    } else {
      覚醒2ポイント.value = 0;
    }
  }
  
  findShortestPath(targetNode, activeSet) {
    // BFSで最短パスを探索
    const distances = new Map();
    const parent = new Map();
    const queue = [];
    
    // 初期化：全アクティブノードを距離0でキューに追加
    activeSet.forEach(slot => {
      distances.set(slot, 0);
      parent.set(slot, null);
      queue.push(slot);
    });
    
    let found = false;
    
    while (queue.length > 0) {
      const current = queue.shift();
      const currentDist = distances.get(current);
      
      if (current === targetNode.slot) {
        found = true;
        break;
      }
      
      // 隣接ノードを探索
      this.nodes.forEach(node => {
        if (distances.has(node.slot)) return;
        
        // currentからnodeへの隣接チェック
        const isAdjacent = 
          (node.requires && node.requires.includes(current)) ||
          (this.nodeMap[current].requires && this.nodeMap[current].requires.includes(node.slot));
        
        if (isAdjacent) {
          distances.set(node.slot, currentDist + 1);
          parent.set(node.slot, current);
          queue.push(node.slot);
        }
      });
    }
    
    if (!found) {
      return null;
    }
    
    // パスを逆順に構築
    const path = [];
    let current = targetNode.slot;
    while (current !== null && !activeSet.has(current)) {
      path.unshift(current);
      current = parent.get(current);
    }
    
    return path;
  }
  
  isAccessible(node, activeSet) {
    // nodeが既にactiveSetのいずれかに隣接しているか（取得可能か）
    if (!node.requires || node.requires.length === 0) {
      return true; // ルートノード
    }
    // 前提条件のいずれか1つでもアクティブなら取得可能
    return node.requires.some(reqId => activeSet.has(reqId));
  }
  
  calculateNodeCost(node, currentActive) {
    // ノードを有効化するのに必要なコスト（前提条件含む）
    let cost = 1;
    if (node.requires) {
      for (const reqId of node.requires) {
        if (!currentActive.has(reqId)) {
          const reqNode = this.nodeMap[reqId];
          if (reqNode) {
            cost += this.calculateNodeCost(reqNode, currentActive);
          }
        }
      }
    }
    return cost;
  }
  
  addRequiredNodes(node, activeSet) {
    if (node.requires) {
      for (const reqId of node.requires) {
        if (!activeSet.has(reqId)) {
          activeSet.add(reqId);
          const reqNode = this.nodeMap[reqId];
          if (reqNode) {
            this.addRequiredNodes(reqNode, activeSet);
          }
        }
      }
    }
  }
  
  addNodeWithRequirements(node, activeSet) {
    this.addRequiredNodes(node, activeSet);
    activeSet.add(node.slot);
  }
  
  // 外部API
  setLockMode(enabled) {
    this.isLockMode = enabled;
  }
  
  reset() {
    this.activeNodes.clear();
    this.lockedNodes.clear();
    // ルートノードを再初期化
    this.initializeRootNodes();
    this.updatePointDisplay();
    this.draw();
  }
}

// グローバル変数として公開
window.AwakenSkillTree = AwakenSkillTree;
 
const { createApp, computed } = Vue;


// 互換性のための単一スキル参照（最初のスキルを参照）
const 職業 = computed({
  get: () => スキルリスト.value[0]?.職業 || '',
  set: (val) => {
    if (スキルリスト.value[0]) スキルリスト.value[0].職業 = val;
  }
});

const スキル名 = computed({
  get: () => スキルリスト.value[0]?.スキル名 || '',
  set: (val) => {
    if (スキルリスト.value[0]) スキルリスト.value[0].スキル名 = val;
  }
});

const 選択中スキル = computed(() => {
  const currentSkill = get現在スキル();
  if (!currentSkill) return null;
  
  return スキルマスター.value.find(skill =>
    skill.職業 === currentSkill.職業 && skill.スキル名 === currentSkill.スキル名
  );
});

const updateSkillValues = (tabIndex = null) => {
  // tabIndexが指定されていない場合は現在のタブを使用
  const currentSkill = スキルリスト.value[tabIndex];
  
  if (!currentSkill || !currentSkill.スキルID) return;
  
  // スキルIDで検索（攻撃/召喚を区別）
  const skill = スキルマスター.value.find(s => s.ID === currentSkill.スキルID);
  
  if (!skill) return;
  
  const level = currentSkill.レベル;
  currentSkill.倍率 = skill.係数初期値 + (skill.係数上昇値 * (level - 1));
  currentSkill.追加ダメ = skill.固定ダメージ初期値 + (skill.固定ダメージ上昇値 * (level - 1));
  
  // HIT数の自動設定（マスターデータから取得、または既存値を維持）
  if (skill.ヒット数) {
    currentSkill.HIT数 = skill.ヒット数;
  }

  // スキルタイプ（攻撃/召喚）を設定
  currentSkill.タイプ = skill.スキルタイプ;

  currentSkill.召喚補正 = skill.召喚補正;
  currentSkill.召喚補正上昇値 = skill.召喚補正上昇値;

  inputs.value.攻撃タイプ = skill.物理or魔法;
  inputs.value.スキルタイプ = skill.スキルタイプ;
  
  // 互換性のため旧変数も更新（最初のスキルの場合のみ）
  if (tabIndex === 0) {
    inputs.value.スキル倍率 = currentSkill.倍率;
    inputs.value.スキル追加ダメ = currentSkill.追加ダメ;
    inputs.value.ヒット数 = currentSkill.HIT数;
    スキルレベル.value = currentSkill.レベル;
  }
};

const getRefsByType = (type) => ({
  敵名: type === '一般' ? 敵名_一般 : 敵名_ボス,
  難易度: type === '一般' ? 難易度_一般 : 難易度_ボス,
  敵ステータス: type === '一般' ? 敵ステータス_一般 : 敵ステータス_ボス
});

const updateEnemyValues = (enemyType) => {
  const dungeonData = get選択中ダンジョン敵データ(enemyType);
  if (!dungeonData) return;

  const refs = getRefsByType(enemyType);
  const selectedEnemy = dungeonData.enemies.find(e => e.name === refs.敵名.value);
  if (!selectedEnemy) return;

  Object.assign(refs.敵ステータス.value, {
    防御: selectedEnemy.baseStats.defense,
    幸運: selectedEnemy.baseStats.luck
  });

  if (refs.難易度.value) {
    const difficultyData = selectedEnemy.difficultyStats[refs.難易度.value];
    if (difficultyData) {
      Object.assign(refs.敵ステータス.value, {
        ダメ減: difficultyData.dmgReduce,
        ダメ減_乗算: difficultyData.dmgReduceRatio,
        クリ減: difficultyData.critReduce
      });
    }
  }
};

// スキルタブ操作用の関数
const onJobChange = (tabIndex) => {
  const skill = スキルリスト.value[tabIndex];
  if (skill) skill.スキル名 = '';
  updateSkillValues(tabIndex);
};

const onSkillChange = (tabIndex) => {
  const currentSkill = スキルリスト.value[tabIndex];
  if (!currentSkill) return;
  
  // スキルIDで検索
  const masterSkill = スキルマスター.value.find(s => s.ID === currentSkill.スキルID);
  if (masterSkill) {
    currentSkill.スキル名 = masterSkill.スキル名;
    currentSkill.レベル = masterSkill.最大レベル;
    updateSkillValues(tabIndex);
  }
};

const onSkillLevelChange = (tabIndex) => {
  updateSkillValues(tabIndex);
};




// 一般ダメージ計算（常に計算）
const 一般ダメージ = computed(() => {
  return calculateResults(敵ステータス_一般.value, '一般');
});

// ボスダメージ計算（常に計算）
const ボスダメージ = computed(() => {
  return calculateResults(敵ステータス_ボス.value, 'ボス');
});

// 加重平均ダメージ計算
const 加重平均ダメージ = computed(() => {
  const 一般結果 = 一般ダメージ.value;
  const ボス結果 = ボスダメージ.value;
  
  return {
    damage: calcWeightedAverage(一般結果.damage, ボス結果.damage),
    dps: calcWeightedAverage(一般結果.dps, ボス結果.dps),
    baseDamage: calcWeightedAverage(一般結果.baseDamage, ボス結果.baseDamage),
    criRate: calcWeightedAverage(一般結果.criRate, ボス結果.criRate),
    criDamage: calcWeightedAverage(一般結果.criDamage, ボス結果.criDamage)
  };
});

// 表示用の結果（タブに応じて切り替え）
const results = computed(() => {
  const current = 敵タブ.value === '一般' ? 一般ダメージ.value : ボスダメージ.value;
  
  if (!current) return { damage: 0, dps: 0, baseDamage: 0, criRate: 0, criDamage: 0, damagePerStat: {} };
  
  saveToStorage();
  
  // damagePerStatの加重平均を計算
  const damagePerStat = {};
  const bossImportance = ボス重要度.value / 100;
  const generalImportance = 1 - bossImportance;
  
  const generalStats = 一般ダメージ.value?.damagePerStat;
  const bossStats = ボスダメージ.value?.damagePerStat;
  
  // 全てのキーを取得
  const allKeys = new Set([...Object.keys(generalStats), ...Object.keys(bossStats)]);
  
      for (const key of allKeys) {
        damagePerStat[key] = generalStats[key] * generalImportance + bossStats[key] * bossImportance;
      }
  
  return {
    ...current,
    weightedDamage: 加重平均ダメージ.value.damage,
    weightedDps: 加重平均ダメージ.value.dps,
    damagePerStat,
    // ランキング計算用に両方のダメージ値を保持
    ダメージ_一般: 一般ダメージ.value.damage,
    ダメージ_ボス: ボスダメージ.value.damage,
  };
});

const transcend1Rankings = computed(() => calculateTranscend1Rankings());
const transcend2_1Rankings = computed(() => calculateTranscend2_1Rankings());
const transcend2_2Rankings = computed(() => calculateTranscend2_2Rankings());
const transcend2_3Rankings = computed(() => calculateTranscend2_3Rankings());
const petPassiveRankings = computed(() => calculatePetPassiveRankings());
const allGuildSkillRankings = computed(() => calculateGuildSkillRankings());
const awaken1Rankings = computed(() => calculateAwaken1Rankings());
const awaken2Rankings = computed(() => calculateAwaken2Rankings());

const filteredPetPassiveRankings = computed(() => {
  const rankings = petPassiveRankings.value;
  return {
    headers: rankings.headers,
    data: rankings.data
  };
});

const filteredGuildSkillRankings = computed(() => {
  const allRankings = allGuildSkillRankings.value;
  
  const selectedGrades = Object.entries(guildSkillGradeFilters.value)
    .filter(([_, enabled]) => enabled)
    .map(([grade, _]) => grade);
  
  // 全てチェックされている場合のみ全データを返す
  if (selectedGrades.length === 3) {
    return allRankings;
  }
  
  // 何も選択されていない場合は空のデータを返す
  if (selectedGrades.length === 0) {
    return {
      headers: allRankings.headers,
      data: []
    };
  }
  
  return {
    headers: allRankings.headers,
    data: allRankings.data.filter(skill => selectedGrades.includes(skill.category))
  };
});

// 現在の敵タブでの選択スキル単発ダメージを計算
const 現在スキル単発ダメージ = computed(() => {
  const index = 選択中スキルインデックス.value;
  const skill = スキルリスト.value[index];
  
  
  const currentEnemy = 敵タブ.value === '一般' ? 敵ステータス_一般.value : 敵ステータス_ボス.value;
  return calculateCurrentSkillDamage(currentEnemy, 敵タブ.value, skill);
});

const app = createApp({
  setup() {
    // データを先に読み込む
    loadAllData();

    const restored = loadFromStorage();
    
    // 覚醒Canvas制御用変数（setup内でクロージャとして管理）
    let awakenTree1 = null;
    let awakenTree2 = null;
    
    // Canvas初期化関数
    const initAwakenCanvas = (page) => {
      const canvasId = page === 1 ? 'awaken1-canvas' : 'awaken2-canvas';
      const canvas = document.getElementById(canvasId);
      if (!canvas) return null;
      
      const tree = new window.AwakenSkillTree(canvasId, page);
      
      // Vue状態と同期（Canvas初期化後の状態を取得）
      const activeNodes = page === 1 ? 覚醒1アクティブノード : 覚醒2アクティブノード;
      const lockedNodes = page === 1 ? 覚醒1ロックノード : 覚醒2ロックノード;
      
      // Canvas内部で初期化された状態をVueに反映（上書きしない）
      if (activeNodes.value && activeNodes.value.size > 0) {
        tree.activeNodes = new Set(activeNodes.value);
      }
      if (lockedNodes.value && lockedNodes.value.size > 0) {
        tree.lockedNodes = new Set(lockedNodes.value);
      }
      tree.isLockMode = 覚醒ロックモード.value;
      
      // Canvas状態をVueに反映
      activeNodes.value = new Set(tree.activeNodes);
      lockedNodes.value = new Set(tree.lockedNodes);
      
      const originalUpdatePointDisplay = tree.updatePointDisplay;
      tree.updatePointDisplay = () => {
        activeNodes.value = new Set(tree.activeNodes);
        lockedNodes.value = new Set(tree.lockedNodes);
        
        if (originalUpdatePointDisplay) {
          originalUpdatePointDisplay.call(tree);
        }
      };
      
      return tree;
    };
    
    // タブ切り替え時のCanvas初期化
    const initCanvasForCurrentTab = () => {
      setTimeout(() => {
        if (activeMainTab.value === 'awaken1') {
          awakenTree1 = initAwakenCanvas(1);
        } else if (activeMainTab.value === 'awaken2') {
          awakenTree2 = initAwakenCanvas(2);
        }
      }, 100);
    };
    
    // Canvasコントロール関数
    const toggleAwakenLockMode = () => {
      覚醒ロックモード.value = !覚醒ロックモード.value;
      if (awakenTree1) awakenTree1.setLockMode(覚醒ロックモード.value);
      if (awakenTree2) awakenTree2.setLockMode(覚醒ロックモード.value);
    };
    
    const autoOptimizeAwaken = () => {
      if (activeMainTab.value === 'awaken1' && awakenTree1) {
        awakenTree1.autoOptimize();
      } else if (activeMainTab.value === 'awaken2' && awakenTree2) {
        awakenTree2.autoOptimize();
      }
    };
    
    const resetAwakenCanvas = () => {
      if (activeMainTab.value === 'awaken1' && awakenTree1) {
        awakenTree1.reset();
      } else if (activeMainTab.value === 'awaken2' && awakenTree2) {
        awakenTree2.reset();
      }
    };
    
    // 共通職業（全スキルで共通）
    const 共通職業 = ref('');
    
    // 現在タブの敵ステータスへのアクセサ
    const 敵ステータス = computed(() => {
      return 敵タブ.value === '一般' ? 敵ステータス_一般.value : 敵ステータス_ボス.value;
    });
    
    // 共通職業変更時の処理
    const onCommonJobChange = () => {
      // 全スキルの職業を更新
      スキルリスト.value.forEach(skill => {
        skill.職業 = 共通職業.value;
        skill.スキル名 = '';
      });
    };
    
    // 特定スキルの最大レベルを取得
    const getSkillMaxLevel = (skillData) => {
      if (!skillData.スキル名) return 20;
      const masterSkill = スキルマスター.value.find(s => 
        s.職業 === 共通職業.value && s.スキル名 === skillData.スキル名
      );
      return masterSkill ? masterSkill.最大レベル : 20;
    };
    
    // 共通職業で選択可能なスキル
    const 共通職業選択可能スキル = computed(() => {
      if (!共通職業.value) return [];
      return スキルマスター.value.filter(skill => skill.職業 === 共通職業.value);
    });
    
    if (restored) {
      // スキルリストの職業から共通職業を設定
      if (スキルリスト.value[0]?.職業) {
        共通職業.value = スキルリスト.value[0].職業;
      }
      
      // データ読み込み後にのみスキル値を更新
      if (スキルリスト.value[0]?.スキル名) {
        updateSkillValues(0);
      }
      if (敵名_一般.value && 難易度_一般.value) {
        updateEnemyValues('一般');
      }
      if (敵名_ボス.value && 難易度_ボス.value) {
        updateEnemyValues('ボス');
      }
    }
    
    // 現在選択中のスキルを取得
    const 現在スキル = computed(() => get現在スキル());
    
    // 現在選択中のスキルの最大レベルを取得
    const 現在スキル最大レベル = computed(() => {
      const skill = 選択中スキル.value;
      return skill ? skill.最大レベル : 20;
    });
    
    // タブ指定でのスキル選択肢を取得
    const 選択可能スキルByTab = (tabIndex) => {
      const skill = スキルリスト.value[tabIndex];
      if (!skill) return [];
      return スキルマスター.value.filter(s => s.職業 === skill.職業);
    };

    const 選択可能スキル = computed(() => {
      return スキルマスター.value.filter(skill => skill.職業 === 職業.value);
    });

    const get選択可能難易度 = (type) => {
      const dungeonData = get選択中ダンジョン敵データ(type);
      if (!dungeonData?.enemies[0]?.difficultyStats) return [];
      return Object.keys(dungeonData.enemies[0].difficultyStats).sort((a, b) => Number(a) - Number(b));
    };

    const get選択可能敵 = (type) => {
      const dungeonData = get選択中ダンジョン敵データ(type);
      if (!dungeonData) return [];
      const refs = getRefsByType(type);
      return dungeonData.enemies
        .filter(enemy => enemy.difficultyStats?.[refs.難易度.value])
        .map(enemy => enemy.name);
    };

    const 選択可能難易度_一般 = computed(() => get選択可能難易度('一般'));
    const 選択可能難易度_ボス = computed(() => get選択可能難易度('ボス'));
    const 選択可能敵_一般 = computed(() => get選択可能敵('一般'));
    const 選択可能敵_ボス = computed(() => get選択可能敵('ボス'));

    // resultsのdamagePerStatを別のcomputedに分離（循環参照回避）
    const damagePerStatComputed = computed(() => {
      const generalStats = 一般ダメージ.value?.damagePerStat || {};
      const bossStats = ボスダメージ.value?.damagePerStat || {};
      
      const damagePerStat = {};
      const allKeys = new Set([...Object.keys(generalStats), ...Object.keys(bossStats)]);
      
      for (const key of allKeys) {
        damagePerStat[key] = calcWeightedAverage(generalStats[key], bossStats[key]);
      }
      
      return damagePerStat;
    });

    return {
      // 現在スキル単発ダメージをreturnに追加（reactivity確保のため）
      現在スキル単発ダメージ,
      
      results: computed(() => {
        // 現在の敵タブでの選択スキルの単発ダメージを4つのカードに表示
        const singleSkillDamage = 現在スキル単発ダメージ.value;
        
        // 現在選択中のスキルのHIT数を取得
        const currentSkill = get現在スキル();
        const hitCount = currentSkill?.HIT数;
        
        // 加重平均ダメージ（全スキル×一般ボス）
        const weighted = 加重平均ダメージ.value;
        
        return {
          baseDamage: singleSkillDamage.baseDamage,  // 単発
          criRate: singleSkillDamage.criRate,         // 率なので変わらず
          criDamage: singleSkillDamage.criDamage,     // 単発
          damage: singleSkillDamage.damage * hitCount, // HIT数反映
          weightedDamage: weighted.damage,
          weightedDps: weighted.dps,
          damagePerStat: damagePerStatComputed.value  // 循環参照を解消
        };
      }),
      
      // スキル関連
      スキルリスト,
      選択中スキルインデックス,
      addスキルタブ,
      removeスキルタブ,
      現在スキル,
      現在スキル最大レベル,
      選択可能スキルByTab,
      共通職業,
      onCommonJobChange,
      getSkillMaxLevel,
      共通職業選択可能スキル,
      
      // 互換性のため残す
      職業,
      スキル名,
      スキルレベル,
      最大スキルレベル,
      
      // 敵設定
      ダンジョン_一般,
      ダンジョン_ボス,
      敵名_一般,
      敵名_ボス,
      難易度_一般,
      難易度_ボス,
      敵ステータス_一般,
      敵ステータス_ボス,
      敵ステータス, // 現在タブの敵ステータス
      敵タブ,
      ボス重要度,
      換算方法,
      inputs,
      activeMainTab,
      guildSkillGradeFilters,
      選択可能スキル,
      選択可能敵_一般,
      選択可能敵_ボス,
      選択可能難易度_一般,
      選択可能難易度_ボス,
      スキルマスター,
      敵マスター_一般,
      敵マスター_ボス,
      超越スキルマスター,
      ギルドスキルマスター,
      ペットパッシブマスター,
      職業リスト,
      ダンジョンリスト_一般,
      ダンジョンリスト_ボス,
      results,
      一般ダメージ,
      ボスダメージ,
      加重平均ダメージ,

      base,
      incr: (stat) => {
        const getDamagePerStat = (key) => {
          const general = 一般ダメージ.value?.damagePerStat?.[key];
          const boss = ボスダメージ.value?.damagePerStat?.[key];
          return calcWeightedAverage(general, boss);
        };
        
        const baseStat = getDamagePerStat(stat);
        if (!baseStat) return 0;
        
        // 換算方法に応じて値を変換
        if (換算方法.value === '増加ダメ') {
          return '+' + Math.floor(baseStat);
        } else if (換算方法.value === 'クリダメ換算') {
          const criDamageKey = inputs.value.攻撃タイプ === '物理' ? '物理_クリダメ' : '魔法_クリダメ';
          const criDamageValue = getDamagePerStat(criDamageKey);
          if (!criDamageValue) return baseStat;
          const ratio = baseStat / criDamageValue;
          return ratio >= 1 ? ratio.toFixed(2) : `1/${(1/ratio).toFixed(2)}`;
        } else if (換算方法.value === '筋魔換算') {
          const strIntKey = inputs.value.攻撃タイプ === '物理' ? '筋力' : '魔力';
          const strIntValue = getDamagePerStat(strIntKey);
          if (!strIntValue) return baseStat;
          const ratio = baseStat / strIntValue;
          return ratio >= 1 ? ratio.toFixed(2) : `1/${(1/ratio).toFixed(2)}`;
        }
        return '+' + Math.floor(baseStat);
      },
      formatDamage: (damage) => {
        const oku = Math.floor(damage / 100000000);
        const man = Math.floor((damage % 100000000) / 10000);
        const remainder = Math.floor(damage % 10000);
        
        return (oku ? oku + '億' : '') + 
               (man ? man + '万' : '') + 
               remainder;
      },

      statKeys: computed(() => {
        const allStats = Object.keys(inputs.value.stats);
        return allStats.filter(s => {
          if (s.endsWith('_乗算')) return false;

          // 一般とボスのステータスは両方表示

          if (inputs.value.攻撃タイプ === '物理') {
            return !(s.startsWith('魔') || s.startsWith('属'));
          }
          else {
            return !(s.startsWith('筋') || s.startsWith('物') || s.startsWith('攻'));
          }
        });
      }),
      isPhysical: computed(() => inputs.value.攻撃タイプ === '物理'),
      label: stat => {
        const withoutPrefix = stat.replace(/^(物理|魔法)_/, '');
        if (withoutPrefix.endsWith('乗算')) {
          const withoutSuffix = withoutPrefix.replace(/_乗算$/, '');
          return ['クリダメ', '最大', '最小'].includes(withoutSuffix) ? '最終' : '%';
        }
        return withoutPrefix;
      },
      mulKey,
      hasMultiplier: stat => mulKey(stat) in inputs.value.stats,
      
      currentSkillMaxLevel: 20,
      
      transcend1Rankings,
      transcend2_1Rankings,
      transcend2_2Rankings,
      transcend2_3Rankings,
      petPassiveRankings,
      filteredPetPassiveRankings,
      allGuildSkillRankings,
      filteredGuildSkillRankings,
      覚醒1ポイント,
      覚醒2ポイント,
      覚醒ロックモード,
      awaken1Rankings,
      awaken2Rankings,
      
      // 覚醒Canvas制御関数
      toggleAwakenLockMode,
      autoOptimizeAwaken,
      resetAwakenCanvas,
      
      // タブ切り替え時の処理
      onTabChange: (tabId) => {
        activeMainTab.value = tabId;
        // 覚醒タブに切り替えた時Canvas初期化
        if (tabId === 'awaken1' || tabId === 'awaken2') {
          initCanvasForCurrentTab();
        }
      },
      
      
      selectedSkillTitle: computed(() => {
        const skill = 選択中スキル.value;
        return skill ? `${skill.スキル名} - ${skill.説明 || ''}` : '';
      }),
      currentSkillType: computed(() => inputs.value.スキルタイプ),
      
      // これだけ静的表示項目だがHTML2箇所で使われるため　DRYにするためJSで持つ
      tabLabels: {
        damage: 'ダメージ計算',
        transcend1: '超越１',
        transcend2_1: '超越2 根性',
        transcend2_2: '超越2 貪欲',
        transcend2_3: '超越2 闘志',
        guild: 'ギルドスキル',
        petPassive: 'ペットパッシブ',
        awaken1: '覚醒1',
        awaken2: '覚醒2'
      },
      
      activeRanking: computed(() => {
        const rankings = {
          transcend1: transcend1Rankings,
          transcend2_1: transcend2_1Rankings,
          transcend2_2: transcend2_2Rankings,
          transcend2_3: transcend2_3Rankings,
          guild: filteredGuildSkillRankings,
          petPassive: filteredPetPassiveRankings,
          awaken1: awaken1Rankings,
          awaken2: awaken2Rankings
        };
        return rankings[activeMainTab.value].value;
      }),
      triggerCalculation: () => { },
      onJobChange,
      onSkillChange,
      onSkillLevelChange,
      onDungeonChange: (enemyType) => {
        const refs = getRefsByType(enemyType);
        refs.敵名.value = '';
        
        // 難易度を最大値に自動設定
        const dungeonData = get選択中ダンジョン敵データ(enemyType);
        if (dungeonData?.enemies[0]?.difficultyStats) {
          const difficulties = Object.keys(dungeonData.enemies[0].difficultyStats)
            .sort((a, b) => Number(b) - Number(a));
          if (difficulties.length > 0) refs.難易度.value = difficulties[0];
        }
        
        if (!refs.難易度.value) refs.難易度.value = '';
      },
      onEnemyChange: updateEnemyValues,
      onDifficultyChange: updateEnemyValues,
      isLastCheckedGuildGrade: () => false,
      isLastCheckedPetPriority: () => false
    };
  }
});

app.mount('#app');
