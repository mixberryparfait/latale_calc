/**
 * グローバル単一データストア
 * DRY原則: 同一データは1箇所でのみ管理
 * リアクティビティ粒度を適切に制御するため、変更時の挙動単位でrefを分離
 */

const { ref } = Vue;

const 職業 = ref('');
const スキル名 = ref('');
const ダンジョン = ref('');
const 敵名 = ref('');
const 難易度 = ref('');
const スキルレベル = ref(1);
const 最大スキルレベル = ref(20);

const activeMainTab = ref('damage');
const guildSkillGradeFilters = ref({
  初級: true,
  中級: true,
  上級: true
});

const スキルマスター = ref([]);
const 敵マスター = ref({});
const 超越スキルマスター = ref([]);
const ギルドスキルマスター = ref([]);
const ペットパッシブマスター = ref([]);
const 職業リスト = ref([]);
const ダンジョンリスト = ref([]);

let 超越1初期化データ = [];
let 超越2_1初期化データ = [];
let 超越2_2初期化データ = [];
let 超越2_3初期化データ = [];
let ギルドスキル初期化データ = [];
let ペットパッシブ初期化データ = [];

const inputs = ref({
  攻撃タイプ: '物理',
  スキルタイプ: '攻撃',
  
  スキル倍率: 100,
  スキル追加ダメ: 0,
  モーション時間: null,
  ヒット数: null,
  
  stats: {
    筋力: 546424,
    筋力_乗算: 316,
    魔力: 546424,
    魔力_乗算: 316,
    効率: 0,
    体力: 400512,
    体力_乗算: 620,
    幸運: 400948,
    幸運_乗算: 300,
    
    HP: 4474100,
    HP_乗算: 217,
      
    攻撃最大: 50000,
    攻撃最小: 50000,
    攻撃_乗算: 100,
    属性: 14382,
    属性_乗算: 276,
    
    物理_クリ率: 50,
    魔法_クリ率: 50,
    物理_クリダメ: 1993,
    魔法_クリダメ: 1993,
    クリダメ_乗算: 0,

    物理_最大: 0,
    魔法_最大: 0,
    最大_乗算: 1310,

    物理_最小: 0,
    魔法_最小: 0,
    最小_乗算: 1473,
  
    基礎最大: 105,
    基礎最小: 95,
    
    属性最大: 0,
    属性最小: 0,

    物理_貫通: 90,
    魔法_貫通: 90,

    物理_追加ダメ: 247784,
    魔法_追加ダメ: 247784,
    追加ダメ_乗算: 110,
    
    一般追加ダメ: 122046,
    一般追加ダメ_乗算: 0,
    一般支配: 17.4,
    ボス追加ダメ: 122046,
    ボス追加ダメ_乗算: 0,
    ボス支配: 17.4,
  },
    
  攻撃補正: 100,
  属性補正: 100,
  ダメ補正: 100,
  
  敵タイプ: 'ボス',
  敵防御: 1,
  敵ダメ減: 0,
  敵ダメ減_乗算: 0,
  敵幸運: 1068254,
  敵クリ減: 0,
  
  HPダメージ換算: 100,
  
  経験値: 1243
});

const getCurrentSkillData = () => {
  if (!スキル名.value) return null;
  
  return スキルマスター.value.find(skill => 
    skill.職業 === 職業.value && skill.スキル名 === スキル名.value
  ) || null;
};

const deepMerge = (target, source) => {
  if (!source) return target;
  
  for (const key in target) {
    if (key in source) {
      if (typeof target[key] === 'object' && target[key] !== null && 
          typeof source[key] === 'object' && source[key] !== null) {
        deepMerge(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
};

const loadFromStorage = () => {
  try {
    const saved = localStorage.getItem('lataleCalcData');
    if (saved) {
      const data = JSON.parse(saved);
      
      deepMerge(inputs.value, data.inputs);
      
      職業.value = data.職業 || '';
      スキル名.value = data.スキル名 || '';
      ダンジョン.value = data.ダンジョン || '';
      敵名.value = data.敵名 || '';
      難易度.value = data.難易度 || '';
      スキルレベル.value = data.スキルレベル || 1;
      return true;
    }
  } catch (error) {
    localStorage.removeItem('lataleCalcData');
  }
  return false;
};

const saveToStorage = () => {
  try {
    const data = {
      inputs: inputs.value,
      職業: 職業.value,
      スキル名: スキル名.value,
      ダンジョン: ダンジョン.value,
      敵名: 敵名.value,
      難易度: 難易度.value,
      スキルレベル: スキルレベル.value
    };
    
    localStorage.setItem('lataleCalcData', JSON.stringify(data));
    return true;
  } catch (error) {
    console.error('[saveToStorage] Failed to save settings:', error);
  }
  return false;
};
 
/**
 * ダメージ計算エンジン
 * DRY原則: 計算は1回のみ、動的にキーの存在をチェック
 * 初期化により型を保証、nullチェック不要
 * 
 * 命名規約:
 * - 表示値: ステータス画面に表示される値（補正前値 × 乗算値）
 * - 補正前値: 乗算補正を適用する前のベース値
 * - 乗算値: ％補正の値（100 = 100%増加）
 */

const getStatWithPrefix = (key, stats) => stats[getActualKey(key)];

const isPhysical = () => inputs.value.攻撃タイプ === '物理';

const mulKey = (stat) => {
  if(stat.startsWith('攻撃')) return '攻撃_乗算'
  return stat.replace(/^(物理|魔法)_/, '') + '_乗算';
};

function calculateBaseDamage(stats) {
  
  let 攻撃力補正 = 1;
  let 属性攻撃補正 = 1;
  let 全ダメージ補正 = 1;
  let 効率 = 1;
  
  const 防御倍率 = 1 / Math.exp(inputs.value.敵防御 / 3761.35);
  const 貫通率 = getStatWithPrefix('貫通', stats) / 100;
  
  if (inputs.value.スキルタイプ === '召喚') {
    攻撃力補正 = 1;
    属性攻撃補正 = 1;
    全ダメージ補正 = inputs.value.ダメ補正 / 100;
  } else {
    効率 += stats.効率/ 100;
  }
    
  let 筋魔, 攻撃or属性, 最大, 最小, 追加ダメ;
  
  if (isPhysical()) {
    筋魔 = stats.筋力;
    攻撃or属性 = ((stats.攻撃最大) + (stats.攻撃最小)) * 攻撃力補正;
    最大 = getStatWithPrefix('最大', stats);
    最小 = getStatWithPrefix('最小', stats);
    追加ダメ = getStatWithPrefix('追加ダメ', stats);
  } else {
    筋魔 = stats.魔力;
    攻撃or属性 = (stats.属性) * 2 * 属性攻撃補正;
    最大 = getStatWithPrefix('最大', stats) + (stats.属性最大);
    最小 = getStatWithPrefix('最小', stats) + (stats.属性最小);
    追加ダメ = getStatWithPrefix('追加ダメ', stats);
  }
  
  最大 = Number(最大) + Number(stats.基礎最大);
  最小 = Number(最小) + Number(stats.基礎最小);
  
  追加ダメ += stats[inputs.value.敵タイプ + '追加ダメ']
  追加ダメ -= inputs.value.敵ダメ減;
  const 支配 = stats[inputs.value.敵タイプ + '支配']

  const 基本ダメージ1 = 攻撃or属性 * inputs.value.スキル倍率 / 100;
  const 基本ダメージ2 = inputs.value.スキル追加ダメ + 筋魔 * 効率;
  最小 = Math.min(最大 + 10, 最小);
    
  const result = (
    (基本ダメージ1 + 基本ダメージ2) * (1 - (1 - 防御倍率) * (1 - 貫通率))
      + 追加ダメ
  )
    * (1 + 支配 / 100)
    * (最大 + 最小) / 200 * 全ダメージ補正
    * (1 - inputs.value.敵ダメ減_乗算 / 100);
  
  return result;
}

function calculateCriRate(stats) {
  const クリ率 = getStatWithPrefix('クリ率', stats);
  const 幸運 = stats.幸運;
  return Math.min(100, クリ率 + 15 * 幸運 / inputs.value.敵幸運);
}

function calculateCriDamage(baseDamage, stats) {
  const クリダメ = getStatWithPrefix('クリダメ', stats);
  const クリダメ補正 = (100 + クリダメ) * (1 - inputs.value.敵クリ減 / 1000) / 100;
  return baseDamage * クリダメ補正;
}

function calculateDamage(baseDamage, criRate, criDamage) {
  const cr = criRate / 100;
  const nonCriPart = baseDamage * (1 - cr);
  const criPart = criDamage * cr;
  return nonCriPart + criPart;
}

function calculateDPS(damage) {
  
  const motionTimeInSeconds = inputs.value.モーション時間 / 10;
  const hitCount = inputs.value.ヒット数;
  const totalDamage = damage * hitCount;
  
  return totalDamage / motionTimeInSeconds;
}


const calculateDamages = (stats) => {
  const baseDamage = calculateBaseDamage(stats);
  const criRate = calculateCriRate(stats);
  const criDamage = calculateCriDamage(baseDamage, stats);
  const damage = calculateDamage(baseDamage, criRate, criDamage);
  
  return {
    baseDamage,
    criRate,
    criDamage,
    damage
  };
}

function calculateResults() {
  const stats = inputs.value.stats;
  const baseResults = calculateDamages(stats);
  const currentDamage = baseResults.damage;

  if (inputs.value.モーション時間 === null || inputs.value.ヒット数 === null) {
    baseResults.dps = currentDamage;
  } else {
    baseResults.dps = calculateDPS(currentDamage);
  }

  const damagePerStatPoint = key => {
    if (key === '経験値') {
      return Math.floor(currentDamage / 100 / (1 + stats[key] / 100));
    }

    const hpValue = inputs.value.HPダメージ換算 / 100;
    if (key === 'HP') {
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = (1 + HP_乗算 / 100) / HP;
      return Math.floor(currentDamage * HPincr * hpValue);
    }
    if (key === 'HP_乗算') {
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = (1 / (1 + HP_乗算 / 100)) / 100;
      return Math.floor(currentDamage * HPincr * hpValue);
    }
    if (key === '体力') {
      const 体力_乗算 = stats.体力_乗算;
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = 7 * (1 + 体力_乗算 / 100) * (1 + HP_乗算 / 100) / HP;
      return Math.floor(currentDamage * HPincr * hpValue);
    }
    if (key === '体力_乗算') {
      const 体力 = (stats.体力) / (1 + (stats.体力_乗算) / 100);
      const HP_乗算 = stats.HP_乗算;
      const HP = stats.HP || 1;
      const HPincr = 体力 * 0.01 * 7 * (1 + HP_乗算 / 100) / HP;
      return Math.floor(currentDamage * HPincr * hpValue);
    }

    // 元データを変更しないよう stats をコピー
    const tmp = JSON.parse(JSON.stringify(inputs.value.stats));

    if (key === '攻撃_乗算') {
      const 乗算値 = tmp[key];
      ['攻撃最大', '攻撃最小'].forEach(attackKey => {
        const 補正前値 = tmp[attackKey] / (1 + 乗算値 / 100);
        tmp[attackKey] = 補正前値 * (1 + (乗算値 + 1) / 100);
      });
    } else if (key.endsWith('_乗算')) {
      const baseKey = key.replace('_乗算', '');
      const actualKey = getActualKey(baseKey);
      const 乗算値 = tmp[key];
      const 表示値 = tmp[actualKey];
      const 補正前値 = 表示値 / (1 + 乗算値 / 100);
      tmp[actualKey] = 補正前値 * (1 + (乗算値 + 1) / 100);
    } else if (key === '攻撃最大' || key === '攻撃最小') {
      tmp[key] += 1 + tmp.攻撃_乗算 / 100;
    } else if (key.endsWith('貫通')) {
      tmp[key] = 100 - (100 - tmp[key]) * 0.99;
    } else {
      const actualKey = getActualKey(key);
      const multiplierKey = mulKey(key);
      tmp[actualKey] ++;
      if (multiplierKey in tmp) {
        tmp[actualKey] += tmp[multiplierKey] / 100;
      }  
    }
    const newDamageResult = calculateDamages(tmp);
    return Math.floor(newDamageResult.damage - currentDamage);
  };

  const damagePerStat = {};
  Object.keys(stats).forEach(key => {
    damagePerStat[key] = damagePerStatPoint(key);
  });

  return {
    baseDamage: baseResults.baseDamage,
    criRate: baseResults.criRate,
    criDamage: baseResults.criDamage,
    damage: baseResults.damage,
    dps: baseResults.dps,
    damagePerStat: damagePerStat
  };
}

/**
 * 基本値計算（％補正前の値）
 * @param {string} key - ステータスキー（プレフィックスなし）
 * @param {object} stats - ステータスオブジェクト
 */
function base(key, stats = inputs.value.stats) {
  
  if (key === '攻撃最大' || key === '攻撃最小') {
    const 乗算値 = stats.攻撃_乗算;
    return (stats[key]) / (1 + 乗算値 / 100);
  }
  
  const actualKey = getActualKey(key);
  const 表示値 = stats[actualKey];
  const 乗算キー = key + '_乗算';
  
  if (stats[乗算キー] !== undefined) {
    const 乗算値 = stats[乗算キー];
    return 表示値 / (1 + 乗算値 / 100);
  }
  return 表示値;
}

const getActualKey = (key) => {
  const prefixedKey = `${inputs.value.攻撃タイプ}_${key}`;
  return prefixedKey in inputs.value.stats ? prefixedKey : key;
}
 
/**
 * データローダー
 * JSONファイルから各種マスターデータを読み込み
 * 選択連動処理を管理
 */

// スキルデータ読み込み（JSON形式に変更済み）
async function loadSkills() {
  try {
    const response = await fetch('data/skills.json');
    const skillsData = await response.json();
    スキルマスター.value = skillsData;
    
    // 職業リストを生成（重複排除）
    const jobs = new Set();
    skillsData.forEach(skill => {
      if (skill.職業) jobs.add(skill.職業);
    });
    職業リスト.value = Array.from(jobs).sort();
    
    return true;
  } catch (error) {
    console.error('Failed to load skills:', error);
    return false;
  }
}

// 敵データ読み込み
async function loadEnemies() {
  try {
    const response = await fetch('data/enemies.json');
    const enemiesData = await response.json();
    敵マスター.value = enemiesData;
    
    // ダンジョンリストを生成（dungeon.nameを使用）
    const dungeonList = [];
    for (const levelKey in enemiesData) {
      if (enemiesData[levelKey].dungeon && enemiesData[levelKey].dungeon.name) {
        dungeonList.push({
          level: levelKey,
          name: enemiesData[levelKey].dungeon.name
        });
      }
    }
    // レベル順でソート
    dungeonList.sort((a, b) => parseInt(a.level) - parseInt(b.level));
    ダンジョンリスト.value = dungeonList;
    
    return true;
  } catch (error) {
    console.error('Failed to load enemies:', error);
    return false;
  }
}

// 超越スキルデータ読み込み
async function loadTranscendSkills() {
    const response = await fetch('data/transcend_skills.json');
    const transcendData = await response.json();
    
    // 初期化データを生成して永続保持
    超越1初期化データ = initializeRankingData(transcendData.filter(skill => skill.position <= 3));
    超越2_1初期化データ = initializeRankingData(transcendData.filter(skill => skill.position === 4));
    超越2_2初期化データ = initializeRankingData(transcendData.filter(skill => skill.position === 5));
    超越2_3初期化データ = initializeRankingData(transcendData.filter(skill => skill.position === 6));
    
    // マスターデータは保持しない
    return true;
}

// ギルドスキルデータ読み込み
async function loadGuildSkills() {
    const response = await fetch('data/guild_skills.json');
    const rawData = await response.json();
    
    // 初期化データを生成して永続保持
    ギルドスキル初期化データ = initializeRankingData(rawData);
    
    // マスターデータは保持しない
    return true;
}

// ペットパッシブデータ読み込み
async function loadPetPassives() {
    const response = await fetch('data/pet_passives.json');
    const rawData = await response.json();
    
    // 初期化データを生成して永続保持
    ペットパッシブ初期化データ = initializeRankingData(rawData);
    
    // マスターデータは保持しない
    return true;
}

// 全データ一括読み込み
async function loadAllData() {
  const results = await Promise.all([
    loadSkills(),
    loadEnemies(),
    loadTranscendSkills(),
    loadGuildSkills(),
    loadPetPassives()
  ]);
  
  const success = results.every(r => r === true);
  
  if (!success) {
    console.error('Some data failed to load');
  }
  
  return success;
}

// 選択中のスキルデータ取得
function getSelectedSkillData() {
  if (!スキル名.value) return null;
  
  return スキルマスター.value.find(skill => 
    skill.スキル名 === スキル名.value && skill.職業 === 職業.value
  ) || null;
}

// 選択中の敵データ取得
function getSelectedEnemyData() {
  if (!ダンジョン.value || !敵名.value || !難易度.value) {
    return null;
  }
  
  // ダンジョンリストから選択されたダンジョンのレベルを取得
  const selectedDungeonData = ダンジョンリスト.value.find(d => d.name === ダンジョン.value);
  if (!selectedDungeonData) return null;
  
  const levelKey = selectedDungeonData.level;
  const dungeonData = 敵マスター.value[levelKey];
  if (!dungeonData || !dungeonData.enemies) return null;
  
  // 選択された敵を探す
  const selectedEnemy = dungeonData.enemies.find(e => e.name === 敵名.value);
  if (!selectedEnemy) return null;
  
  // 難易度別のステータスを取得
  const difficultyData = selectedEnemy.difficultyStats[難易度.value];
  if (!difficultyData) return null;
  
  // 基本ステータスと難易度別ステータスを統合して返す
  return {
    type: selectedEnemy.type,
    defense: selectedEnemy.baseStats.defense,
    luck: selectedEnemy.baseStats.luck,
    dmgReduce: difficultyData.dmgReduce,
    dmgReduceRatio: difficultyData.dmgReduceRatio,
    critReduce: difficultyData.critReduce
  };
}

// グローバル公開（window.不要、トップレベル関数はそのままアクセス可能）
 
// ランキング計算関数

/*　マスターjson
{
  name: 名前（必須）,
  position: 分類（オプション）,
  base_cost: （オプション）,
  cost_per_level: レベル毎コスト増分（オプション）,
  max_level: 最大レベル（オプション）,
  status_type1: ステータスタイプ1（必須）,
  status_value1: 初期値1（必須）,
  status_value_slv1: レベル毎増分1（オプション）,
  status_type2: ステータスタイプ2（オプション）,
  status_value2: 初期値2（オプション）,
  status_value_slv2: レベル毎増分2（オプション）,
}

初期化データ：
マスターロード時に生成　マスターデータは記憶しない
cost_per_level が存在すればレベル分レコードを複製
表示用のレベルとコストを固定して damage 以外の値を fix
{
  name: 名前（必須）,
  category: 分類（ギルド　ペット）,
  effect: ステータス（必須）,
  level: LV（cost_per_level ? level : max_level）,
  cost: P（base_cost + cost_per_level * (level - 1)）,
  status_type1: ステータスタイプ1（必須）,
  status_value1: 値1（必須）,
  status_type2: ステータスタイプ2
  status_value2: 値2,
  damage: ダメ/P（必須　ここだけ更新される）
}
calcurateRanking では status_xxx からダメージ増加値を計算し cost で割った値を damage にセットしてソートするだけ

ヘッダ自動生成
[
name if exist: スキル名
category if exist: 分類
effect required, ステータス
level if exist: LV
cost if exist: 消費P
damage requi: cost ? ダメージ/コスト : ダメージ
]
*/

// StatusTypeマッピング（表示用）
const StatusTypeMap = {
  // HP系
  30: 'HP',
  31: 'HP%',
  
  // ステータス系
  14: '筋力',
  15: '筋力%',
  22: '魔力',
  23: '魔力%',
  26: '体力',
  18: '幸運',
  455: '全ステータス',
  456: '全ステータス%',
  594: '筋力魔力',
  595: '筋力魔力%',
  
  // ダメージ系
  461: '最大',
  462: '最小',
  95: '最終最大',
  103: '最終最大',
  91: '最終最小',
  99: '最終最小',
  590: '最終最小',
  591: '最終最大',
  
  // クリティカル系
  464: 'クリダメ',
  465: 'クリ率',
  157: '最終クリダメ',
  163: '最終クリダメ',
  592: '最終クリダメ',
  
  // 追加ダメージ系
  496: '追加ダメ',
  141: '追加ダメ%',
  241: '追加ダメ%',
  588: '追加ダメ%',
  566: '一般追加ダメ',
  570: 'ボス追加ダメ',
  573: '一般支配',
  574: 'ボス支配',
  
  // 属性系
  492: '属性',
  38: '属性',
  493: '属性%',
  39: '属性%',
  586: '属性',
  587: '属性%',
  
  // その他
  463: '貫通',
  216: '防御',
  70: '抵抗力',
  596: '防御抵抗',
  495: 'ダメージ減少',
  86: 'ダメージ減少%',
  440: 'CT',
  106: '移動速度',
  466: '命中率',
  494: 'バックアタック',
  567: '一般追加ダメ%',
  571: 'ボス追加ダメ%',
  208: '筋力効率',
  200: '魔力効率',
  614: 'スキルターゲット数',
  128: 'Ely獲得量',
  132: 'アイテムドロップ率',
  488: 'クエスト報酬',
  124: '経験値',
  
  // 追加されたstatusType
  19: '体力/幸運(%)',
  27: '体力/幸運(%)',
  94: '物理最大ダメージA',
  102: '魔法最大ダメージA',
  144: '物理ダメージ減少A',
  458: '魔法抵抗力',
  497: '回避率A',
  584: '超人ポイントA',
  585: '最小/最大ダメージA'
};

// スキル名の省略形変換マップ
const skillNameAbbreviations = {
  'クリティカルダメージ': 'クリダメ',
  'ダメージ減少': 'ダメ減',
  '一般モンスター追加ダメージ': '一般追加ダメ',
  'ボスモンスター追加ダメージ': 'ボス追加ダメ',
  'バックアタックダメージ': 'BA',
  '一般モンスター支配力': '一般支配',
  'ボスモンスター支配力': 'ボス支配',
  'クールタイム減少': 'CT減少',
  '筋力、魔法力': '筋魔',
  '物理/魔法追加ダメージ': '追加ダメ',
  '全ステータス': '全ステ',
  '武器属性力': '属性',
  '最大HP': 'HP',
  '最小ダメージ': '最小',
  '最大ダメージ': '最大',
  '筋力/魔力効率': '効率',
  'スキルターゲット数': 'タゲ数',
  '移動速度': '移動'
};

// スキル名を短縮形に変換
function shortenSkillName(name) {
  let shortened = name;
  for (const [full, short] of Object.entries(skillNameAbbreviations)) {
    shortened = shortened.replace(full, short);
  }
  // その他の簡略化
  shortened = shortened.replace(/\s*\(\+\)\s*/g, '');
  shortened = shortened.replace(/\s*\(%\)\s*/g, '%');
  shortened = shortened.replace(/\s*-\s*/g, '-');
  shortened = shortened.replace(/\\n/g, '/');
  shortened = shortened.replace('Ⅰ', '1');
  shortened = shortened.replace('Ⅱ', '2');
  return shortened;
}

// ダメージ換算
function calculateDamageIncrease(statusType, value) {
  const damagePerStat = results.value.damagePerStat;
  
  // HP系
  if (statusType === 30) return damagePerStat['HP'] * value;
  if (statusType === 31) return damagePerStat['HP_乗算'] * value;
  
  // ステータス系
  if (statusType === 14) return damagePerStat['筋力'] * value;
  if (statusType === 15) return damagePerStat['筋力_乗算'] * value;
  if (statusType === 22) return damagePerStat['魔力'] * value;
  if (statusType === 23) return damagePerStat['魔力_乗算'] * value;
  if (statusType === 26) return damagePerStat['体力'] * value;
  if (statusType === 18) return damagePerStat['幸運'] * value;
  
  // 体力/幸運(%)
  if (statusType === 19 || statusType === 27) {
    return value * (damagePerStat['体力_乗算'] + damagePerStat['幸運_乗算']);
  }
  
  // 全ステータス
  if (statusType === 455) {
    return value * (damagePerStat['筋力'] + damagePerStat['体力'] + damagePerStat['幸運'] + damagePerStat['魔力']);
  }
  if (statusType === 456) {
    return value * (damagePerStat['筋力_乗算'] + damagePerStat['体力_乗算'] + damagePerStat['幸運_乗算'] + damagePerStat['魔力_乗算']);
  }
  
  // 筋力魔力（より高い方を採用）
  if (statusType === 594) {
    return value * Math.max(damagePerStat['筋力'], damagePerStat['魔力']);
  }
  if (statusType === 595) {
    return value * Math.max(damagePerStat['筋力_乗算'], damagePerStat['魔力_乗算']);
  }
  
  // ダメージ系
  if (statusType === 461) return damagePerStat[getActualKey('最大')] * value;
  if (statusType === 462) return damagePerStat[getActualKey('最小')] * value;
  
  // 最終系ダメージ
  if ([95, 591].includes(statusType)) {
    // 最終最大（103は重複のため除外）
    return damagePerStat['最大_乗算'] * value;
  }
  if ([91, 590].includes(statusType)) {
    // 最終最小（99は重複のため除外）
    return damagePerStat['最小_乗算'] * value;
  }
  
  // 重複マッピングは無効化（103, 99, 163, 241, 39）
  if ([103, 99, 163, 241, 39].includes(statusType)) {
    return 0;  // not calc
  }
  
  // クリティカル系
  if (statusType === 464) return damagePerStat[getActualKey('クリダメ')] * value;
  if (statusType === 465) return damagePerStat[getActualKey('クリ率')] * value;
  if ([157, 592].includes(statusType)) {
    // 最終クリダメ（163は重複のため除外）
    return damagePerStat['クリダメ_乗算'] * value;
  }
  
  // 追加ダメージ系
  if (statusType === 496) return damagePerStat[getActualKey('追加ダメ')] * value;
  if ([141, 588].includes(statusType)) {
    // 追加ダメ%（241は重複のため除外）
    return damagePerStat['追加ダメ_乗算'] * value;
  }
  if (statusType === 566) return damagePerStat['一般追加ダメ'] * value;
  if (statusType === 570) return damagePerStat['ボス追加ダメ'] * value;
  if (statusType === 567) return damagePerStat['一般追加ダメ_乗算'] * value;
  if (statusType === 571) return damagePerStat['ボス追加ダメ_乗算'] * value;
  if (statusType === 573) return damagePerStat['一般支配'] * value;
  if (statusType === 574) return damagePerStat['ボス支配'] * value;
  
  // 武器属性力の特殊処理
  if ([492, 38, 586].includes(statusType)) {
    // 武器属性力(+) = 攻撃最大 + 攻撃最小 + 属性
    return value * (damagePerStat['攻撃最大'] + damagePerStat['攻撃最小'] + damagePerStat['属性']);
  }
  if ([493, 587].includes(statusType)) {
    // 武器属性力(%) = 攻撃% + 属性%（39は重複のため除外）
    return value * (damagePerStat['攻撃_乗算'] + damagePerStat['属性_乗算']);
  }
  
  // その他
  if (statusType === 463) return damagePerStat[getActualKey('貫通')] * value;
  // if (statusType === 106) return damagePerStat['移動'] * value;
  // if (statusType === 466) return damagePerStat['命中率'] * value;
  
  // 効率系（暫定で計算不可）
  if ([/* 208, */200].includes(statusType)) return damagePerStat['効率'] * value;
  
  // その他計算不可
  return 0;
}

// 入力値のハッシュを生成（変更検出用）
function generateInputHash(stats) {
  const keys = ['str', 'vit', 'int', 'magic', 'agi', 'attrFire', 'attrWater', 'attrLight', 'attrWind'];
  return keys.map(k => stats[k]).join(',');
}

// 初期化データ生成（共通）
function initializeRankingData(skills) {
  const initialData = [];
  
  for (const skill of skills) {
    // 固定コストなら1回、可変コストならmax_level回
    const maxIterations = (skill.cost_per_level && skill.cost_per_level > 0) ? skill.max_level : 1;
    
    for (let level = 1; level <= maxIterations; level++) {
      const effects = [];
      
      // このレベルでの実際の値を計算
      const value1 = skill.status_value1 + (skill.status_value_slv1 || 0) * (level - 1);
      const value2 = skill.status_type2 > 0 ? 
        skill.status_value2 + (skill.status_value_slv2 || 0) * (level - 1) : 0;
      
      // エフェクト文字列を生成
      processStatusEffects(skill, value1, value2, effects);

      const dataItem = {
        id: skill.id,
        name: skill.name,
        effect: effects.join(skill.position === 5 ? '<br>' : ', '),
        // ステータス情報を保持（ダメージ計算用）
        status_type1: skill.status_type1,
        status_value1: value1,
        status_type2: skill.status_type2,
        status_value2: value2,
        // 初期値
        damage: 0
      };
      
      if ('category' in skill) dataItem.category = skill.category;
      if ('position' in skill) dataItem.position = skill.position;
            
      // レベルとコスト
      if ('base_cost' in skill) {
        if('max_level' in skill) {
          dataItem.cost = skill.base_cost + (level - 1) * (skill.cost_per_level || 0);
          dataItem.level = skill.cost_per_level > 0 ? level : skill.max_level;
        }
        else {
          dataItem.cost = skill.base_cost;
        }
      }
      
      initialData.push(dataItem);
    }
  }
  
  return initialData;
}

// ダメージ計算と更新（共通）
function calculateRankingDamage(data) {
  // 各アイテムのダメージを計算
  for (const item of data) {
    let totalDamageIncrease = 0;
    
    // ステータス1のダメージ計算
    if (item.status_value1) {
      const dmg1 = calculateDamageIncrease(item.status_type1, item.status_value1);
      totalDamageIncrease += dmg1;
    }
    
    // ステータス2のダメージ計算
    if (item.status_type2 > 0 && item.status_value2) {
      const dmg2 = calculateDamageIncrease(item.status_type2, item.status_value2);
      totalDamageIncrease += dmg2;
    }
    
    // コストがある場合はコストで割る
    if ('cost' in item && item.cost > 0) {
      item.damage = totalDamageIncrease / item.cost;
    } else {
      item.damage = totalDamageIncrease;
    }
  }
  
  // ソート
  return data.sort((a, b) => b.damage - a.damage);
}

// ヘッダー自動生成
function generateHeaders(data) {
  const headers = ['順位'];
  const sample = data[0];
  
  if (!sample) return headers;
  
  if ('name' in sample) headers.push('名前');
  if ('category' in sample) headers.push('分類');
  if ('effect' in sample) headers.push('ステータス');
  if ('level' in sample) headers.push('Lv');
  if ('cost' in sample) {
    headers.push('P');
    headers.push('ダメージ/P');
  }
  else {
    headers.push('ダメージ');
  }
  
  return headers;
}

// ステータスエフェクト処理（共通化）
function processStatusEffects(skill, value1, value2, effects) {
  let totalDamageIncrease = 0;
  
  // 筋力効率と魔力効率が同じ値の場合
  if ((skill.status_type1 === 208 && skill.status_type2 === 200) || 
      (skill.status_type1 === 200 && skill.status_type2 === 208)) {
    if (value1 !== value2) {
      throw new Error('筋力魔力効率が異なる');
    }
    totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
    totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value1);
    effects.push(`効率+${value1}`);
  }
  // 筋力%と魔力%が同じ値の場合
  else if ((skill.status_type1 === 15 && skill.status_type2 === 23) || 
      (skill.status_type1 === 23 && skill.status_type2 === 15)) {
    if (value1 !== value2) {
      throw new Error('筋力魔力%が異なる');
    }
    totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
    totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value2);
    effects.push(`筋魔+${value1}%`);
  }
  // 筋力と魔力が同じ値の場合
  else if ((skill.status_type1 === 14 && skill.status_type2 === 22) || 
           (skill.status_type1 === 22 && skill.status_type2 === 14)) {
    if (value1 !== value2) {
      throw new Error('筋力魔力が異なる');
    }
    totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
    totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value2);
    effects.push(`筋魔+${value1}`);
  }
  // その他の場合
  else {
    if (value1 !== 0) {
      totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
      effects.push(buildEffectString(skill.status_type1, value1));
    }
    
    if (skill.status_type2 > 0 && value2 !== 0) {
      totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value2);
      effects.push(buildEffectString(skill.status_type2, value2));
    }
  }
  
  return totalDamageIncrease;
}

// ランキング計算関数のファクトリー（共通処理）
function createRankingCalculator(initialData) {
  return () => {
    const rankedData = calculateRankingDamage(initialData);
    return {
      headers: generateHeaders(rankedData),
      data: rankedData
    };
  };
}

// 各ランキング計算関数を生成
const calculateTranscend1Rankings = () => createRankingCalculator(超越1初期化データ)();
const calculateTranscend2_1Rankings = () => createRankingCalculator(超越2_1初期化データ)();
const calculateTranscend2_2Rankings = () => createRankingCalculator(超越2_2初期化データ)();
const calculateTranscend2_3Rankings = () => createRankingCalculator(超越2_3初期化データ)();

// 効果文字列生成ヘルパー
function buildEffectString(statusType, value) {
  
  // 特殊ケースの名前変換
  const specialNames = {
    455: '全ステ', 456: '全ステ%',
    594: '筋魔', 595: '筋魔%',
    492: '武器属性', 38: '武器属性', 586: '武器属性',
    493: '武器属性%', 39: '武器属性%', 587: '武器属性%'
  };
  
  const statName = specialNames[statusType] || StatusTypeMap[statusType];

  // パーセント系の処理
  const isPercent = statName.endsWith('%');
  const displayName = isPercent ? statName.slice(0, -1) : statName;
  
  // 符号処理: 正の数には+を付け、負の数はそのまま（既に-が付いている）
  const sign = value > 0 ? '+' : '';
  return `${displayName}${sign}${value}${isPercent ? '%' : ''}`;
}

/* 
[{
cost_per_level, 
max_level, 
status_value_slv1, 
skill.status_value1, 
status_type1,  
status_value1,
status_type2,  
status_value2
}]
*/
const calculateRankings = skills => {
  const rankings = [];
  
  for (const skill of skills) {
    // 固定コストならループは1回、可変コストならmax_level回
    const maxIterations = skill.cost_per_level === 0 ? 1 : skill.max_level;
    
    for (let level = 1; level <= maxIterations; level++) {
      // このレベルでの実際の値を計算
      let totalDamageIncrease = 0;
      const effects = [];
      
      const value1 = skill.status_value_slv1 + skill.status_value1 * (level - 1);
      const value2 = skill.status_type2 > 0 ? skill.status_value_slv2 + skill.status_value2 * (level - 1) : 0;
      
      // 筋力効率と魔力効率が同じ値の場合は「効率」として表示
      if ((skill.status_type1 === 208 && skill.status_type2 === 200) || 
          (skill.status_type1 === 200 && skill.status_type2 === 208)) {
        if (value1 !== value2) {
          throw new Error('筋力魔力効率が異なる');
        }
        totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
        totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value1);
        effects.push(`効率+${value1}`);
      }
      // 筋力%と魔力%が同じ値の場合は「筋魔%」として表示
      else if ((skill.status_type1 === 15 && skill.status_type2 === 23) || 
          (skill.status_type1 === 23 && skill.status_type2 === 15)) {
        if (value1 !== value2) {
          throw new Error('筋力魔力効%が異なる');
        }
        totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
        totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value2);
        effects.push(`筋魔+${value1}%`);
      }
      // 筋力と魔力（値のみ）が同じ値の場合は「筋魔」として表示
      else if ((skill.status_type1 === 14 && skill.status_type2 === 22) || 
               (skill.status_type1 === 22 && skill.status_type2 === 14)) {
        if (value1 !== value2) {
          throw new Error('筋力魔力効が異なる');
        }
          totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
          totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value2);
          effects.push(`筋魔+${value1}`);
      }
      // その他の場合は通常通り処理
      else {
        if (value1 !== 0) {
          totalDamageIncrease += calculateDamageIncrease(skill.status_type1, value1);
          const effect1 = buildEffectString(skill.status_type1, value1);
          effects.push(effect1);
        }
        
        if (skill.status_type2 > 0 && value2 !== 0) {
          totalDamageIncrease += calculateDamageIncrease(skill.status_type2, value2);
          const effect2 = buildEffectString(skill.status_type2, value2);
          effects.push(effect2);
        }
      }
      
      const cost = skill.base_cost + (level - 1) * skill.cost_per_level;
      const valuePerPoint = totalDamageIncrease / cost;
      
      if (valuePerPoint > 0) {
        rankings.push({
          id: skill.id,
          name: skill.name,
          position: skill.position,
          level: skill.cost_per_level > 0 ? level : '*',
          effects: [...new Set(effects)].join(skill.position == 5 ? '<br>' : ', '),
          cost: cost,
          damageIncrease: Math.floor(totalDamageIncrease),
          costPerPoint: Math.floor(valuePerPoint),
          isFixedCost: skill.cost_per_level === 0,
        });
      }
    }
  }
  
  return rankings.sort((a, b) => b.costPerPoint - a.costPerPoint).slice(0, 1000);
}

const calculateGuildSkillRankings = () => createRankingCalculator(ギルドスキル初期化データ)();
const calculatePetPassiveRankings = () => createRankingCalculator(ペットパッシブ初期化データ)();
 
const { createApp, computed } = Vue;

const 選択中スキル = computed(() => {
  return スキルマスター.value.find(skill =>
    skill.職業 === 職業.value && skill.スキル名 === スキル名.value
  );
});

const updateSkillValues = () => {
  const skill = 選択中スキル.value;
  if (!skill) return;
  
  const level = スキルレベル.value;
  const skillPower = skill.係数初期値;
  const powerPerLevel = skill.係数上昇値;
  const baseDamage = skill.固定ダメージ初期値;
  const damagePerLevel = skill.固定ダメージ上昇値;

  inputs.value.スキル倍率 = skillPower + (powerPerLevel * (level - 1));
  inputs.value.スキル追加ダメ = baseDamage + (damagePerLevel * (level - 1));
  inputs.value.モーション時間 = skill.モーション時間 || 1;
  inputs.value.ヒット数 = skill.ヒット数 || null;

  if (skill.物理or魔法) {
    inputs.value.攻撃タイプ = skill.物理or魔法;
  }
  if (skill.スキルタイプ) {
    inputs.value.スキルタイプ = skill.スキルタイプ;
  }
};

const updateEnemyValues = () => {
  const selectedDungeonData = ダンジョンリスト.value.find(d => d.name === ダンジョン.value);
  if (!selectedDungeonData) return;

  const dungeonData = 敵マスター.value[selectedDungeonData.level];

  const selectedEnemy = dungeonData.enemies.find(e => e.name === 敵名.value);
  if (!selectedEnemy) return;

  inputs.value.敵タイプ = selectedEnemy.type;

  inputs.value.敵防御 = selectedEnemy.baseStats.defense;
  inputs.value.敵幸運 = selectedEnemy.baseStats.luck;

  if (難易度.value) {
    const difficultyData = selectedEnemy.difficultyStats[難易度.value];
    if (difficultyData) {
      inputs.value.敵ダメ減 = difficultyData.dmgReduce;
      inputs.value.敵ダメ減_乗算 = difficultyData.dmgReduceRatio;
      inputs.value.敵クリ減 = difficultyData.critReduce;
    }
  }
};

const onJobChange = () => {
  スキル名.value = '';
};

const onSkillChange = () => {
  const skill = 選択中スキル.value;
  if (!skill) return;
  スキルレベル.value = skill.最大レベル;
  updateSkillValues();
};

const onSkillLevelChange = () => {
  updateSkillValues();
};

const onDungeonChange = () => {
  難易度.value = '';
  敵名.value = '';
};

const onDifficultyChange = () => {
  updateEnemyValues();
};

const onEnemyChange = () => {
  updateEnemyValues();
};


const results = computed(() => {
  const calcResults = calculateResults();
  saveToStorage();

  return calcResults;
});

const transcend1Rankings = computed(() => {
  return calculateTranscend1Rankings();
});

const transcend2_1Rankings = computed(() => {
  return calculateTranscend2_1Rankings();
});

const transcend2_2Rankings = computed(() => {
  return calculateTranscend2_2Rankings();
});

const transcend2_3Rankings = computed(() => {
  return calculateTranscend2_3Rankings();
});

const petPassiveRankings = computed(() => {
  return calculatePetPassiveRankings();
});

const allGuildSkillRankings = computed(() => {
  return calculateGuildSkillRankings();
});

const filteredPetPassiveRankings = computed(() => {
  const rankings = petPassiveRankings.value;
  return {
    headers: rankings.headers,
    data: rankings.data
  };
});

const filteredGuildSkillRankings = computed(() => {
  const allRankings = allGuildSkillRankings.value;
  
  const selectedGrades = Object.entries(guildSkillGradeFilters.value)
    .filter(([_, enabled]) => enabled)
    .map(([grade, _]) => grade);
  
  if (selectedGrades.length === 0 || selectedGrades.length === 3) {
    return allRankings;
  }
  
  return {
    headers: allRankings.headers,
    data: allRankings.data.filter(skill => selectedGrades.includes(skill.category))
  };
});

const app = createApp({
  setup() {
    const restored = loadFromStorage();
    if (restored) {
      if (スキル名.value) {
        updateSkillValues();
      }
      if (敵名.value && 難易度.value) {
        updateEnemyValues();
      }
    }

    const 選択可能スキル = computed(() => {
      return スキルマスター.value.filter(skill => skill.職業 === 職業.value);
    });

    const 選択可能難易度 = computed(() => {
      const selectedDungeonData = ダンジョンリスト.value.find(d => d.name === ダンジョン.value);
      if (!selectedDungeonData) return [];

      const dungeonData = 敵マスター.value[selectedDungeonData.level];
      
      const firstEnemy = dungeonData.enemies[0];
      
      return Object.keys(firstEnemy.difficultyStats).sort((a, b) => Number(a) - Number(b));
    });

    const 選択可能敵 = computed(() => {
      const selectedDungeonData = ダンジョンリスト.value.find(d => d.name === ダンジョン.value);
      if (!selectedDungeonData) return [];

      const dungeonData = 敵マスター.value[selectedDungeonData.level];
      
      return dungeonData.enemies
        .filter(enemy => enemy.difficultyStats && enemy.difficultyStats[難易度.value])
        .map(enemy => enemy.name);
    });
    
    loadAllData();

    return {
      results,
      
      職業,
      スキル名,
      ダンジョン,
      敵名,
      難易度,
      スキルレベル,
      最大スキルレベル,
      inputs,
      activeMainTab,
      guildSkillGradeFilters,
      選択可能スキル,
      選択可能敵,
      選択可能難易度,
      スキルマスター,
      敵マスター,
      超越スキルマスター,
      ギルドスキルマスター,
      ペットパッシブマスター,
      職業リスト,
      ダンジョンリスト,
      results,

      base,
      incr: (stat) => results.value.damagePerStat[stat],
      formatDamage: (damage) => {
        const oku = Math.floor(damage / 100000000);
        const man = Math.floor((damage % 100000000) / 10000);
        const remainder = Math.floor(damage % 10000);
        
        return (oku ? oku + '億' : '') + 
               (man ? man + '万' : '') + 
               remainder;
      },

      statKeys: computed(() => {
        const allStats = Object.keys(inputs.value.stats);
        return allStats.filter(s => {
          if (s.endsWith('_乗算')) return false;

          if (s.startsWith('一般') && inputs.value.敵タイプ === 'ボス'
            || s.startsWith('ボス') && inputs.value.敵タイプ !== 'ボス') {
            return false;
          }

          if (inputs.value.攻撃タイプ === '物理') {
            return !(s.startsWith('魔') || s.startsWith('属'));
          }
          else {
            return !(s.startsWith('筋') || s.startsWith('物') || s.startsWith('攻'));
          }
        });
      }),
      isPhysical: computed(() => inputs.value.攻撃タイプ === '物理'),
      label: stat => {
        const withoutPrefix = stat.replace(/^(物理|魔法)_/, '');
        if (withoutPrefix.endsWith('乗算')) {
          const withoutSuffix = withoutPrefix.replace(/_乗算$/, '');
          return ['クリダメ', '最大', '最小'].includes(withoutSuffix) ? '最終' : '%';
        }
        return withoutPrefix;
      },
      mulKey,
      hasMultiplier: stat => mulKey(stat) in inputs.value.stats,
      
      currentSkillMaxLevel: 20,
      
      transcend1Rankings,
      transcend2_1Rankings,
      transcend2_2Rankings,
      transcend2_3Rankings,
      petPassiveRankings,
      filteredPetPassiveRankings,
      allGuildSkillRankings,
      filteredGuildSkillRankings,
      selectedSkillTitle: computed(() => {
        const skill = 選択中スキル.value;
        return skill ? `${skill.スキル名} - ${skill.説明 || ''}` : '';
      }),
      currentSkillType: computed(() => inputs.value.スキルタイプ),
      
      // これだけ静的表示項目だがHTML2箇所で使われるため　DRYにするためJSで持つ
      tabLabels: {
        damage: 'ダメージ計算',
        transcend1: '超越１',
        transcend2_1: '超越2 根性',
        transcend2_2: '超越2 貪欲',
        transcend2_3: '超越2 闘志',
        guild: 'ギルドスキル',
        petPassive: 'ペットパッシブ'
      },
      
      activeRanking: computed(() => {
        const rankings = {
          transcend1: transcend1Rankings,
          transcend2_1: transcend2_1Rankings,
          transcend2_2: transcend2_2Rankings,
          transcend2_3: transcend2_3Rankings,
          guild: filteredGuildSkillRankings,
          petPassive: filteredPetPassiveRankings
        };
        return rankings[activeMainTab.value].value;
      }),
      
      triggerCalculation: () => { },
      onJobChange,
      onSkillChange,
      onSkillLevelChange,
      onDungeonChange,
      onEnemyChange,
      onDifficultyChange,
      isLastCheckedGuildGrade: () => false,
      isLastCheckedPetPriority: () => false
    };
  }
});

app.mount('#app');
